from typing import Any, ClassVar, Iterator, List, Optional, Union

from typing import overload
import os

class ASTContext:
    def __init__(self, scope, lookupLocation, flags: ASTFlags = ...) -> None: ...
    def addAssertionBacktrace(self, arg0) -> None: ...
    def addDiag(self, *args, **kwargs) -> Any: ...
    def eval(self, *args, **kwargs) -> Any: ...
    def evalDimension(self, arg0, arg1: bool, arg2: bool) -> EvaluatedDimension: ...
    @overload
    def evalInteger(self, arg0, arg1: ASTFlags) -> Optional[int]: ...
    @overload
    def evalInteger(self, arg0) -> Optional[int]: ...
    def evalPackedDimension(self, *args, **kwargs) -> Any: ...
    def evalUnpackedDimension(self, *args, **kwargs) -> Any: ...
    def getRandMode(self, *args, **kwargs) -> Any: ...
    def requireBooleanConvertible(self, arg0) -> bool: ...
    def requireGtZero(self, arg0: Optional[int], arg1) -> bool: ...
    @overload
    def requireIntegral(self, arg0) -> bool: ...
    @overload
    def requireIntegral(self, arg0, arg1) -> bool: ...
    def requireNoUnknowns(self, arg0, arg1) -> bool: ...
    @overload
    def requirePositive(self, arg0, arg1) -> bool: ...
    @overload
    def requirePositive(self, arg0: Optional[int], arg1) -> bool: ...
    def requireSimpleExpr(self, *args, **kwargs) -> Any: ...
    @overload
    def requireValidBitWidth(self, arg0: int, arg1) -> bool: ...
    @overload
    def requireValidBitWidth(self, arg0, arg1) -> Optional[int]: ...
    def resetFlags(self, arg0: ASTFlags) -> ASTContext: ...
    def tryEval(self, *args, **kwargs) -> Any: ...
    @property
    def flags(self) -> ASTFlags: ...
    @property
    def getCompilation(self) -> Any: ...
    @property
    def getContainingSubroutine(self) -> Any: ...
    @property
    def getDriverKind(self) -> Any: ...
    @property
    def getInstance(self) -> Any: ...
    @property
    def getLocation(self) -> Any: ...
    @property
    def getProceduralBlock(self) -> Any: ...
    @property
    def inAlwaysCombLatch(self) -> bool: ...
    @property
    def inUnevaluatedBranch(self) -> bool: ...
    @property
    def lookupIndex(self) -> Any: ...
    @property
    def scope(self) -> Any: ...

class ASTFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowClockingBlock: ClassVar[ASTFlags] = ...
    AllowCoverageSampleFormal: ClassVar[ASTFlags] = ...
    AllowCoverpoint: ClassVar[ASTFlags] = ...
    AllowDataType: ClassVar[ASTFlags] = ...
    AllowInterconnect: ClassVar[ASTFlags] = ...
    AllowNetType: ClassVar[ASTFlags] = ...
    AllowTypeReferences: ClassVar[ASTFlags] = ...
    AllowUnboundedLiteral: ClassVar[ASTFlags] = ...
    AllowUnboundedLiteralArithmetic: ClassVar[ASTFlags] = ...
    AssertionDelayOrRepetition: ClassVar[ASTFlags] = ...
    AssertionExpr: ClassVar[ASTFlags] = ...
    AssertionInstanceArgCheck: ClassVar[ASTFlags] = ...
    AssignmentAllowed: ClassVar[ASTFlags] = ...
    AssignmentDisallowed: ClassVar[ASTFlags] = ...
    ConcurrentAssertActionBlock: ClassVar[ASTFlags] = ...
    EnumInitializer: ClassVar[ASTFlags] = ...
    EventExpression: ClassVar[ASTFlags] = ...
    Final: ClassVar[ASTFlags] = ...
    Function: ClassVar[ASTFlags] = ...
    InsideConcatenation: ClassVar[ASTFlags] = ...
    LValue: ClassVar[ASTFlags] = ...
    NoAttributes: ClassVar[ASTFlags] = ...
    NonBlockingTimingControl: ClassVar[ASTFlags] = ...
    NonProcedural: ClassVar[ASTFlags] = ...
    None: ClassVar[ASTFlags] = ...
    OutputArg: ClassVar[ASTFlags] = ...
    ProceduralAssign: ClassVar[ASTFlags] = ...
    ProceduralForceRelease: ClassVar[ASTFlags] = ...
    PropertyNegation: ClassVar[ASTFlags] = ...
    PropertyTimeAdvance: ClassVar[ASTFlags] = ...
    RecursivePropertyArg: ClassVar[ASTFlags] = ...
    StaticInitializer: ClassVar[ASTFlags] = ...
    StreamingAllowed: ClassVar[ASTFlags] = ...
    StreamingWithRange: ClassVar[ASTFlags] = ...
    TopLevelStatement: ClassVar[ASTFlags] = ...
    UnevaluatedBranch: ClassVar[ASTFlags] = ...
    UnrollableForLoop: ClassVar[ASTFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AbortAssertionExpr(AssertionExpr):
    class Action:
        __members__: ClassVar[dict] = ...  # read-only
        Accept: ClassVar[AbortAssertionExpr.Action] = ...
        Reject: ClassVar[AbortAssertionExpr.Action] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Accept: ClassVar[AbortAssertionExpr.Action] = ...
    Reject: ClassVar[AbortAssertionExpr.Action] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def action(self) -> Any: ...
    @property
    def condition(self) -> Expression: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def isSync(self) -> bool: ...

class AcceptOnPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    expr: PropertyExprSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ActionBlockSyntax(SyntaxNode):
    elseClause: ElseClauseSyntax
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AnsiPortListSyntax(PortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Any
    def __init__(self, *args, **kwargs) -> None: ...

class AnsiUdpPortListSyntax(UdpPortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ArgumentDirection:
    __members__: ClassVar[dict] = ...  # read-only
    In: ClassVar[ArgumentDirection] = ...
    InOut: ClassVar[ArgumentDirection] = ...
    Out: ClassVar[ArgumentDirection] = ...
    Ref: ClassVar[ArgumentDirection] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ArgumentListSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    parameters: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ArgumentSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ArrayOrRandomizeMethodExpressionSyntax(ExpressionSyntax):
    args: ParenExpressionListSyntax
    constraints: ConstraintBlockSyntax
    method: ExpressionSyntax
    with: Token
    def __init__(self, *args, **kwargs) -> None: ...

class AssertionExpr:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def admitsEmpty(self) -> bool: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> AssertionExprKind: ...
    @property
    def syntax(self) -> Any: ...

class AssertionExprKind:
    __members__: ClassVar[dict] = ...  # read-only
    Abort: ClassVar[AssertionExprKind] = ...
    Binary: ClassVar[AssertionExprKind] = ...
    Case: ClassVar[AssertionExprKind] = ...
    Clocking: ClassVar[AssertionExprKind] = ...
    Conditional: ClassVar[AssertionExprKind] = ...
    DisableIff: ClassVar[AssertionExprKind] = ...
    FirstMatch: ClassVar[AssertionExprKind] = ...
    Invalid: ClassVar[AssertionExprKind] = ...
    SequenceConcat: ClassVar[AssertionExprKind] = ...
    SequenceWithMatch: ClassVar[AssertionExprKind] = ...
    Simple: ClassVar[AssertionExprKind] = ...
    StrongWeak: ClassVar[AssertionExprKind] = ...
    Unary: ClassVar[AssertionExprKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AssertionInstanceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> Any: ...
    @property
    def body(self) -> Any: ...
    @property
    def isRecursiveProperty(self) -> bool: ...
    @property
    def localVars(self) -> Any: ...
    @property
    def symbol(self) -> Any: ...

class AssertionItemPortListSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    ports: Any
    def __init__(self, *args, **kwargs) -> None: ...

class AssertionItemPortSyntax(SyntaxNode):
    attributes: Any
    defaultValue: EqualsAssertionArgClauseSyntax
    dimensions: Any
    direction: Token
    local: Token
    name: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AssertionKind:
    __members__: ClassVar[dict] = ...  # read-only
    Assert: ClassVar[AssertionKind] = ...
    Assume: ClassVar[AssertionKind] = ...
    CoverProperty: ClassVar[AssertionKind] = ...
    CoverSequence: ClassVar[AssertionKind] = ...
    Expect: ClassVar[AssertionKind] = ...
    Restrict: ClassVar[AssertionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AssertionPortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def localVarDirection(self) -> Optional[ArgumentDirection]: ...
    @property
    def type(self) -> Any: ...

class AssignmentExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isCompound(self) -> bool: ...
    @property
    def isLValueArg(self) -> bool: ...
    @property
    def isNonBlocking(self) -> bool: ...
    @property
    def left(self) -> Expression: ...
    @property
    def op(self) -> Optional[BinaryOperator]: ...
    @property
    def right(self) -> Expression: ...
    @property
    def timingControl(self) -> Any: ...

class AssignmentPatternExpressionBase(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elements(self) -> span[Expression]: ...

class AssignmentPatternExpressionSyntax(PrimaryExpressionSyntax):
    pattern: AssignmentPatternSyntax
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AssignmentPatternItemSyntax(SyntaxNode):
    colon: Token
    expr: ExpressionSyntax
    key: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AssignmentPatternSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class AssociativeArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def indexType(self) -> Type: ...

class AttributeInstanceSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    specs: Any
    def __init__(self, *args, **kwargs) -> None: ...

class AttributeSpecSyntax(SyntaxNode):
    name: Token
    value: EqualsValueClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class AttributeSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> ConstantValue: ...

class BadExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class Bag:
    compilationOptions: CompilationOptions
    lexerOptions: Any
    parserOptions: Any
    preprocessorOptions: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: list) -> None: ...

class BeginKeywordsDirectiveSyntax(DirectiveSyntax):
    versionSpecifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BinSelectWithFilterExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> BinsSelectExpr: ...
    @property
    def filter(self) -> Expression: ...
    @property
    def matchesExpr(self) -> Expression: ...

class BinSelectWithFilterExprSyntax(BinsSelectExpressionSyntax):
    closeParen: Token
    expr: BinsSelectExpressionSyntax
    filter: ExpressionSyntax
    matchesClause: MatchesClauseSyntax
    openParen: Token
    with: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> AssertionExpr: ...
    @property
    def op(self) -> BinaryAssertionOperator: ...
    @property
    def right(self) -> AssertionExpr: ...

class BinaryAssertionOperator:
    __members__: ClassVar[dict] = ...  # read-only
    And: ClassVar[BinaryAssertionOperator] = ...
    Iff: ClassVar[BinaryAssertionOperator] = ...
    Implies: ClassVar[BinaryAssertionOperator] = ...
    Intersect: ClassVar[BinaryAssertionOperator] = ...
    NonOverlappedFollowedBy: ClassVar[BinaryAssertionOperator] = ...
    NonOverlappedImplication: ClassVar[BinaryAssertionOperator] = ...
    Or: ClassVar[BinaryAssertionOperator] = ...
    OverlappedFollowedBy: ClassVar[BinaryAssertionOperator] = ...
    OverlappedImplication: ClassVar[BinaryAssertionOperator] = ...
    SUntil: ClassVar[BinaryAssertionOperator] = ...
    SUntilWith: ClassVar[BinaryAssertionOperator] = ...
    Throughout: ClassVar[BinaryAssertionOperator] = ...
    Until: ClassVar[BinaryAssertionOperator] = ...
    UntilWith: ClassVar[BinaryAssertionOperator] = ...
    Within: ClassVar[BinaryAssertionOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BinaryBinsSelectExpr(BinsSelectExpr):
    class Op:
        __members__: ClassVar[dict] = ...  # read-only
        And: ClassVar[BinaryBinsSelectExpr.Op] = ...
        Or: ClassVar[BinaryBinsSelectExpr.Op] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    And: ClassVar[BinaryBinsSelectExpr.Op] = ...
    Or: ClassVar[BinaryBinsSelectExpr.Op] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> BinsSelectExpr: ...
    @property
    def op(self) -> Any: ...
    @property
    def right(self) -> BinsSelectExpr: ...

class BinaryBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    left: BinsSelectExpressionSyntax
    op: Token
    right: BinsSelectExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryBlockEventExpressionSyntax(BlockEventExpressionSyntax):
    left: BlockEventExpressionSyntax
    orKeyword: Token
    right: BlockEventExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryEventExpressionSyntax(EventExpressionSyntax):
    left: EventExpressionSyntax
    operatorToken: Token
    right: EventExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def op(self) -> BinaryOperator: ...
    @property
    def right(self) -> Expression: ...

class BinaryExpressionSyntax(ExpressionSyntax):
    attributes: Any
    left: ExpressionSyntax
    operatorToken: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinaryOperator:
    __members__: ClassVar[dict] = ...  # read-only
    Add: ClassVar[BinaryOperator] = ...
    ArithmeticShiftLeft: ClassVar[BinaryOperator] = ...
    ArithmeticShiftRight: ClassVar[BinaryOperator] = ...
    BinaryAnd: ClassVar[BinaryOperator] = ...
    BinaryOr: ClassVar[BinaryOperator] = ...
    BinaryXnor: ClassVar[BinaryOperator] = ...
    BinaryXor: ClassVar[BinaryOperator] = ...
    CaseEquality: ClassVar[BinaryOperator] = ...
    CaseInequality: ClassVar[BinaryOperator] = ...
    Divide: ClassVar[BinaryOperator] = ...
    Equality: ClassVar[BinaryOperator] = ...
    GreaterThan: ClassVar[BinaryOperator] = ...
    GreaterThanEqual: ClassVar[BinaryOperator] = ...
    Inequality: ClassVar[BinaryOperator] = ...
    LessThan: ClassVar[BinaryOperator] = ...
    LessThanEqual: ClassVar[BinaryOperator] = ...
    LogicalAnd: ClassVar[BinaryOperator] = ...
    LogicalEquivalence: ClassVar[BinaryOperator] = ...
    LogicalImplication: ClassVar[BinaryOperator] = ...
    LogicalOr: ClassVar[BinaryOperator] = ...
    LogicalShiftLeft: ClassVar[BinaryOperator] = ...
    LogicalShiftRight: ClassVar[BinaryOperator] = ...
    Mod: ClassVar[BinaryOperator] = ...
    Multiply: ClassVar[BinaryOperator] = ...
    Power: ClassVar[BinaryOperator] = ...
    Subtract: ClassVar[BinaryOperator] = ...
    WildcardEquality: ClassVar[BinaryOperator] = ...
    WildcardInequality: ClassVar[BinaryOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BinaryPropertyExprSyntax(PropertyExprSyntax):
    left: PropertyExprSyntax
    op: Token
    right: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BinarySequenceExprSyntax(SequenceExprSyntax):
    left: SequenceExprSyntax
    op: Token
    right: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BindDirectiveSyntax(MemberSyntax):
    bind: Token
    instantiation: HierarchyInstantiationSyntax
    target: NameSyntax
    targetInstances: BindTargetListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BindTargetListSyntax(SyntaxNode):
    colon: Token
    targets: Any
    def __init__(self, *args, **kwargs) -> None: ...

class BinsSelectConditionExprSyntax(BinsSelectExpressionSyntax):
    binsof: Token
    closeParen: Token
    intersects: IntersectClauseSyntax
    name: NameSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BinsSelectExpr:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> BinsSelectExprKind: ...
    @property
    def syntax(self) -> Any: ...

class BinsSelectExprKind:
    __members__: ClassVar[dict] = ...  # read-only
    Binary: ClassVar[BinsSelectExprKind] = ...
    Condition: ClassVar[BinsSelectExprKind] = ...
    CrossId: ClassVar[BinsSelectExprKind] = ...
    Invalid: ClassVar[BinsSelectExprKind] = ...
    SetExpr: ClassVar[BinsSelectExprKind] = ...
    Unary: ClassVar[BinsSelectExprKind] = ...
    WithFilter: ClassVar[BinsSelectExprKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class BinsSelectExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class BinsSelectionSyntax(MemberSyntax):
    equals: Token
    expr: BinsSelectExpressionSyntax
    iff: CoverageIffClauseSyntax
    keyword: Token
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BitSelectSyntax(SelectorSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class BlockCoverageEventSyntax(SyntaxNode):
    atat: Token
    closeParen: Token
    expr: BlockEventExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class BlockEventExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class BlockEventListControl(TimingControl):
    class Event:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def isBegin(self) -> bool: ...
        @property
        def target(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def events(self) -> Any: ...

class BlockStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def blockKind(self) -> Any: ...
    @property
    def blockSymbol(self) -> Any: ...
    @property
    def body(self) -> Statement: ...

class BlockStatementSyntax(StatementSyntax):
    begin: Token
    blockName: NamedBlockClauseSyntax
    end: Token
    endBlockName: NamedBlockClauseSyntax
    items: Any
    def __init__(self, *args, **kwargs) -> None: ...

class BreakStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class BufferID:
    placeholder: ClassVar[BufferID] = ...  # read-only
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: BufferID) -> bool: ...
    def __ge__(self, arg0: BufferID) -> bool: ...
    def __gt__(self, arg0: BufferID) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, arg0: BufferID) -> bool: ...
    def __lt__(self, arg0: BufferID) -> bool: ...
    def __ne__(self, arg0: BufferID) -> bool: ...
    @property
    def id(self) -> int: ...

class BumpAllocator:
    def __init__(self) -> None: ...

class CHandleType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class CallExpression(Expression):
    class IteratorCallInfo:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def iterExpr(self) -> Expression: ...
        @property
        def iterVar(self) -> Any: ...

    class RandomizeCallInfo:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def constraintRestrictions(self) -> span[str]: ...
        @property
        def inlineConstraints(self) -> Any: ...

    class SystemCallInfo:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def extraInfo(self) -> Union[None,CallExpression.IteratorCallInfo,CallExpression.RandomizeCallInfo]: ...
        @property
        def scope(self) -> Any: ...
        @property
        def subroutine(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[Expression]: ...
    @property
    def isSystemCall(self) -> bool: ...
    @property
    def subroutine(self) -> Any: ...
    @property
    def subroutineKind(self) -> Any: ...
    @property
    def subroutineName(self) -> str: ...
    @property
    def thisClass(self) -> Expression: ...

class CaseAssertionExpr(AssertionExpr):
    class ItemGroup:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def body(self) -> AssertionExpr: ...
        @property
        def expressions(self) -> span[Expression]: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultCase(self) -> AssertionExpr: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def items(self) -> Any: ...

class CaseGenerateSyntax(MemberSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    endCase: Token
    items: Any
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CaseItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class CasePropertyExprSyntax(PropertyExprSyntax):
    caseKeyword: Token
    closeParen: Token
    endcase: Token
    expr: ExpressionSyntax
    items: Any
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CaseStatement(Statement):
    class ItemGroup:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expressions(self) -> span[Expression]: ...
        @property
        def stmt(self) -> Statement: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def check(self) -> CaseStatementCheck: ...
    @property
    def condition(self) -> CaseStatementCondition: ...
    @property
    def defaultCase(self) -> Statement: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def items(self) -> Any: ...

class CaseStatementCheck:
    __members__: ClassVar[dict] = ...  # read-only
    None: ClassVar[CaseStatementCheck] = ...
    Priority: ClassVar[CaseStatementCheck] = ...
    Unique: ClassVar[CaseStatementCheck] = ...
    Unique0: ClassVar[CaseStatementCheck] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CaseStatementCondition:
    __members__: ClassVar[dict] = ...  # read-only
    Inside: ClassVar[CaseStatementCondition] = ...
    Normal: ClassVar[CaseStatementCondition] = ...
    WildcardJustZ: ClassVar[CaseStatementCondition] = ...
    WildcardXOrZ: ClassVar[CaseStatementCondition] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CaseStatementSyntax(StatementSyntax):
    caseKeyword: Token
    closeParen: Token
    endcase: Token
    expr: ExpressionSyntax
    items: Any
    matchesOrInside: Token
    openParen: Token
    uniqueOrPriority: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CastExpressionSyntax(ExpressionSyntax):
    apostrophe: Token
    left: ExpressionSyntax
    right: ParenthesizedExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CellConfigRuleSyntax(ConfigRuleSyntax):
    cell: Token
    name: ConfigCellIdentifierSyntax
    ruleClause: ConfigRuleClauseSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ChargeStrengthSyntax(NetStrengthSyntax):
    closeParen: Token
    openParen: Token
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerDataDeclarationSyntax(MemberSyntax):
    data: DataDeclarationSyntax
    rand: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    keyword: Token
    members: Any
    name: Token
    portList: AssertionItemPortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerInstanceStatementSyntax(StatementSyntax):
    instance: CheckerInstantiationSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CheckerInstantiationSyntax(MemberSyntax):
    instances: Any
    parameters: ParameterValueAssignmentSyntax
    semi: Token
    type: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClassDeclarationSyntax(MemberSyntax):
    classKeyword: Token
    endBlockName: NamedBlockClauseSyntax
    endClass: Token
    extendsClause: ExtendsClauseSyntax
    implementsClause: ImplementsClauseSyntax
    items: Any
    lifetime: Token
    name: Token
    parameters: ParameterPortListSyntax
    semi: Token
    virtualOrInterface: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClassMethodDeclarationSyntax(MemberSyntax):
    declaration: FunctionDeclarationSyntax
    qualifiers: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ClassMethodPrototypeSyntax(MemberSyntax):
    prototype: FunctionPrototypeSyntax
    qualifiers: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClassNameSyntax(NameSyntax):
    identifier: Token
    parameters: ParameterValueAssignmentSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClassPropertyDeclarationSyntax(MemberSyntax):
    declaration: MemberSyntax
    qualifiers: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ClassPropertySymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def randMode(self) -> RandMode: ...
    @property
    def visibility(self) -> Visibility: ...

class ClassType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def baseClass(self) -> Type: ...
    @property
    def baseConstructorCall(self) -> Expression: ...
    @property
    def firstForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def genericClass(self) -> Any: ...
    @property
    def implementedInterfaces(self) -> span[Type]: ...
    @property
    def isAbstract(self) -> bool: ...
    @property
    def isInterface(self) -> bool: ...

class ClockVarSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def inputSkew(self) -> ClockingSkew: ...
    @property
    def outputSkew(self) -> ClockingSkew: ...

class ClockingAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def clocking(self) -> TimingControl: ...
    @property
    def expr(self) -> AssertionExpr: ...

class ClockingBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultInputSkew(self) -> ClockingSkew: ...
    @property
    def defaultOutputSkew(self) -> ClockingSkew: ...
    @property
    def event(self) -> TimingControl: ...

class ClockingDeclarationSyntax(MemberSyntax):
    at: Token
    blockName: Token
    clocking: Token
    endBlockName: NamedBlockClauseSyntax
    endClocking: Token
    event: EventExpressionSyntax
    globalOrDefault: Token
    items: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingDirectionSyntax(SyntaxNode):
    input: Token
    inputSkew: ClockingSkewSyntax
    output: Token
    outputSkew: ClockingSkewSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingEventExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def timingControl(self) -> Any: ...

class ClockingItemSyntax(MemberSyntax):
    decls: Any
    direction: ClockingDirectionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingPropertyExprSyntax(PropertyExprSyntax):
    event: TimingControlSyntax
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingSequenceExprSyntax(SequenceExprSyntax):
    event: TimingControlSyntax
    expr: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ClockingSkew:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def edge(self) -> EdgeKind: ...
    @property
    def hasValue(self) -> bool: ...

class ClockingSkewSyntax(SyntaxNode):
    delay: TimingControlSyntax
    edge: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ColonExpressionClauseSyntax(SyntaxNode):
    colon: Token
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class Compilation:
    defaultTimeScale: Any
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0) -> None: ...
    def addDiagnostics(self, arg0) -> None: ...
    def addSyntaxTree(self, arg0) -> None: ...
    def addSystemMethod(self, arg0, arg1) -> None: ...
    def addSystemSubroutine(self, arg0) -> None: ...
    def createScriptScope(self, *args, **kwargs) -> Any: ...
    def getAllDiagnostics(self, *args, **kwargs) -> Any: ...
    def getNetType(self, *args, **kwargs) -> Any: ...
    def getParseDiagnostics(self, *args, **kwargs) -> Any: ...
    def getRoot(self, *args, **kwargs) -> Any: ...
    def getSemanticDiagnostics(self, *args, **kwargs) -> Any: ...
    def getSyntaxTrees(self, *args, **kwargs) -> Any: ...
    def getSystemMethod(self, *args, **kwargs) -> Any: ...
    def getSystemSubroutine(self, *args, **kwargs) -> Any: ...
    def getType(self, *args, **kwargs) -> Any: ...
    def parseName(self, *args, **kwargs) -> Any: ...
    def tryParseName(self, *args, **kwargs) -> Any: ...
    @property
    def bitType(self) -> Any: ...
    @property
    def byteType(self) -> Any: ...
    @property
    def errorType(self) -> Any: ...
    @property
    def intType(self) -> Any: ...
    @property
    def integerType(self) -> Any: ...
    @property
    def isFinalized(self) -> bool: ...
    @property
    def logicType(self) -> Any: ...
    @property
    def nullType(self) -> Any: ...
    @property
    def options(self) -> CompilationOptions: ...
    @property
    def realType(self) -> Any: ...
    @property
    def shortRealType(self) -> Any: ...
    @property
    def sourceManager(self) -> Any: ...
    @property
    def stringType(self) -> Any: ...
    @property
    def typeRefType(self) -> Any: ...
    @property
    def unboundedType(self) -> Any: ...
    @property
    def unsignedIntType(self) -> Any: ...
    @property
    def voidType(self) -> Any: ...
    @property
    def wireNetType(self) -> Any: ...

class CompilationOptions:
    allowDupInitialDrivers: bool
    allowHierarchicalConst: bool
    errorLimit: int
    lintMode: bool
    maxConstexprBacktrace: int
    maxConstexprDepth: int
    maxConstexprSteps: int
    maxDefParamSteps: int
    maxGenerateSteps: int
    maxInstanceDepth: int
    minTypMax: MinTypMax
    paramOverrides: List[str]
    relaxEnumConversions: bool
    strictDriverChecking: bool
    suppressUnused: bool
    topModules: Set[str]
    typoCorrectionLimit: int
    def __init__(self) -> None: ...

class CompilationUnitSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def timeScale(self) -> TimeScale: ...

class CompilationUnitSyntax(SyntaxNode):
    endOfFile: Token
    members: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ConcatenationExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def operands(self) -> span[Expression]: ...

class ConcatenationExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    expressions: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConcurrentAssertionMemberSyntax(MemberSyntax):
    statement: ConcurrentAssertionStatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConcurrentAssertionStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assertionKind(self) -> Any: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...
    @property
    def propertySpec(self) -> Any: ...

class ConcurrentAssertionStatementSyntax(StatementSyntax):
    action: ActionBlockSyntax
    closeParen: Token
    keyword: Token
    openParen: Token
    propertyOrSequence: Token
    propertySpec: PropertySpecSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def intersects(self) -> span[Expression]: ...
    @property
    def target(self) -> Any: ...

class ConditionalAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def condition(self) -> Expression: ...
    @property
    def elseExpr(self) -> AssertionExpr: ...
    @property
    def ifExpr(self) -> AssertionExpr: ...

class ConditionalBranchDirectiveSyntax(DirectiveSyntax):
    disabledTokens: Any
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elseBody(self) -> Constraint: ...
    @property
    def ifBody(self) -> Constraint: ...
    @property
    def predicate(self) -> Expression: ...

class ConditionalConstraintSyntax(ConstraintItemSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    constraints: ConstraintItemSyntax
    elseClause: ElseConstraintClauseSyntax
    ifKeyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalExpression(Expression):
    class Condition:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def pattern(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def conditions(self) -> Any: ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...

class ConditionalExpressionSyntax(ExpressionSyntax):
    attributes: Any
    colon: Token
    left: ExpressionSyntax
    predicate: ConditionalPredicateSyntax
    question: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPathDeclarationSyntax(MemberSyntax):
    closeParen: Token
    keyword: Token
    openParen: Token
    path: PathDeclarationSyntax
    predicate: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPatternSyntax(SyntaxNode):
    expr: ExpressionSyntax
    matchesClause: MatchesClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPredicateSyntax(SyntaxNode):
    conditions: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    elseClause: ElsePropertyClauseSyntax
    expr: PropertyExprSyntax
    ifKeyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConditionalStatement(Statement):
    class Condition:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def pattern(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def conditions(self) -> Any: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...

class ConditionalStatementSyntax(StatementSyntax):
    closeParen: Token
    elseClause: ElseClauseSyntax
    ifKeyword: Token
    openParen: Token
    predicate: ConditionalPredicateSyntax
    statement: StatementSyntax
    uniqueOrPriority: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigCellIdentifierSyntax(SyntaxNode):
    cell: Token
    dot: Token
    library: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigDeclarationSyntax(MemberSyntax):
    blockName: NamedBlockClauseSyntax
    config: Token
    design: Token
    endconfig: Token
    localparams: Any
    name: Token
    rules: Any
    semi1: Token
    semi2: Token
    topCells: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigInstanceIdentifierSyntax(SyntaxNode):
    dot: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigLiblistSyntax(ConfigRuleClauseSyntax):
    liblist: Token
    libraries: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigRuleClauseSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigRuleSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConfigUseClauseSyntax(ConfigRuleClauseSyntax):
    colon: Token
    config: Token
    name: ConfigCellIdentifierSyntax
    paramAssignments: ParameterValueAssignmentSyntax
    use: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConstantPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class ConstantRange:
    __hash__: ClassVar[None] = ...
    left: int
    right: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int, arg1: int) -> None: ...
    def containsPoint(self, arg0: int) -> bool: ...
    def getIndexedRange(self, arg0: int, arg1: bool, arg2: bool) -> Optional[ConstantRange]: ...
    def overlaps(self, arg0: ConstantRange) -> bool: ...
    def reverse(self) -> ConstantRange: ...
    def subrange(self, arg0: ConstantRange) -> ConstantRange: ...
    def translateIndex(self, arg0: int) -> int: ...
    def __eq__(self, arg0: ConstantRange) -> bool: ...
    def __ne__(self, arg0: ConstantRange) -> bool: ...
    @property
    def isLittleEndian(self) -> bool: ...
    @property
    def lower(self) -> int: ...
    @property
    def upper(self) -> int: ...
    @property
    def width(self) -> int: ...

class ConstantValue:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SVInt) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    def bitstreamWidth(self) -> int: ...
    def convertToByteArray(self, arg0: int, arg1: bool) -> ConstantValue: ...
    def convertToByteQueue(self, arg0: bool) -> ConstantValue: ...
    @overload
    def convertToInt(self) -> ConstantValue: ...
    @overload
    def convertToInt(self, arg0: int, arg1: bool, arg2: bool) -> ConstantValue: ...
    def convertToReal(self) -> ConstantValue: ...
    def convertToShortReal(self) -> ConstantValue: ...
    def convertToStr(self) -> ConstantValue: ...
    def empty(self) -> bool: ...
    def getSlice(self, arg0: int, arg1: int, arg2: ConstantValue) -> ConstantValue: ...
    def hasUnknown(self) -> bool: ...
    def isContainer(self) -> bool: ...
    def isFalse(self) -> bool: ...
    def isTrue(self) -> bool: ...
    def size(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: ConstantValue) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: ConstantValue) -> bool: ...
    @property
    def value(self) -> object: ...

class Constraint:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> ConstraintKind: ...
    @property
    def syntax(self) -> Any: ...

class ConstraintBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def constraints(self) -> Constraint: ...
    @property
    def isExplicitExtern(self) -> bool: ...
    @property
    def isExtern(self) -> bool: ...
    @property
    def isPure(self) -> bool: ...
    @property
    def isStatic(self) -> bool: ...
    @property
    def thisVar(self) -> VariableSymbol: ...

class ConstraintBlockSyntax(ConstraintItemSyntax):
    closeBrace: Token
    items: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintDeclarationSyntax(MemberSyntax):
    block: ConstraintBlockSyntax
    keyword: Token
    name: NameSyntax
    qualifiers: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ConstraintKind:
    __members__: ClassVar[dict] = ...  # read-only
    Conditional: ClassVar[ConstraintKind] = ...
    DisableSoft: ClassVar[ConstraintKind] = ...
    Expression: ClassVar[ConstraintKind] = ...
    Foreach: ClassVar[ConstraintKind] = ...
    Implication: ClassVar[ConstraintKind] = ...
    Invalid: ClassVar[ConstraintKind] = ...
    List: ClassVar[ConstraintKind] = ...
    SolveBefore: ClassVar[ConstraintKind] = ...
    Uniqueness: ClassVar[ConstraintKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ConstraintList(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def list(self) -> span[Constraint]: ...

class ConstraintPrototypeSyntax(MemberSyntax):
    keyword: Token
    name: NameSyntax
    qualifiers: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ContinueStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class ContinuousAssignSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assignment(self) -> Expression: ...
    @property
    def delay(self) -> TimingControl: ...

class ContinuousAssignSyntax(MemberSyntax):
    assign: Token
    assignments: Any
    delay: TimingControlSyntax
    semi: Token
    strength: DriveStrengthSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ConversionExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def conversionKind(self) -> ConversionKind: ...
    @property
    def isImplicit(self) -> bool: ...
    @property
    def operand(self) -> Expression: ...

class ConversionKind:
    __members__: ClassVar[dict] = ...  # read-only
    BitstreamCast: ClassVar[ConversionKind] = ...
    Explicit: ClassVar[ConversionKind] = ...
    Implicit: ClassVar[ConversionKind] = ...
    Propagated: ClassVar[ConversionKind] = ...
    StreamingConcat: ClassVar[ConversionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CopyClassExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def sourceExpr(self) -> Expression: ...

class CopyClassExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    scopedNew: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CoverCrossBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def crossQueueType(self) -> Any: ...

class CoverCrossSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def iffExpr(self) -> Expression: ...
    @property
    def options(self) -> span[CoverageOptionSetter]: ...
    @property
    def targets(self) -> span[CoverpointSymbol]: ...

class CoverCrossSyntax(MemberSyntax):
    closeBrace: Token
    cross: Token
    emptySemi: Token
    iff: CoverageIffClauseSyntax
    items: Any
    label: NamedLabelSyntax
    members: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageBinInitializerSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageBinSymbol(Symbol):
    class BinKind:
        __members__: ClassVar[dict] = ...  # read-only
        Bins: ClassVar[CoverageBinSymbol.BinKind] = ...
        IgnoreBins: ClassVar[CoverageBinSymbol.BinKind] = ...
        IllegalBins: ClassVar[CoverageBinSymbol.BinKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class TransRangeList:
        class RepeatKind:
            __members__: ClassVar[dict] = ...  # read-only
            Consecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            GoTo: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            Nonconsecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            None: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        Consecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        GoTo: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        Nonconsecutive: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        None: ClassVar[CoverageBinSymbol.TransRangeList.RepeatKind] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def items(self) -> span[Expression]: ...
        @property
        def repeatFrom(self) -> Expression: ...
        @property
        def repeatKind(self) -> Any: ...
        @property
        def repeatTo(self) -> Expression: ...
    Bins: ClassVar[CoverageBinSymbol.BinKind] = ...
    IgnoreBins: ClassVar[CoverageBinSymbol.BinKind] = ...
    IllegalBins: ClassVar[CoverageBinSymbol.BinKind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def binsKind(self) -> Any: ...
    @property
    def crossSelectExpr(self) -> BinsSelectExpr: ...
    @property
    def iffExpr(self) -> Expression: ...
    @property
    def isArray(self) -> bool: ...
    @property
    def isDefault(self) -> bool: ...
    @property
    def isDefaultSequence(self) -> bool: ...
    @property
    def isWildcard(self) -> bool: ...
    @property
    def numberOfBinsExpr(self) -> Expression: ...
    @property
    def setCoverageExpr(self) -> Expression: ...
    @property
    def values(self) -> span[Expression]: ...
    @property
    def withExpr(self) -> Expression: ...

class CoverageBinsArraySizeSyntax(SyntaxNode):
    closeBracket: Token
    expr: ExpressionSyntax
    openBracket: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageBinsSyntax(MemberSyntax):
    equals: Token
    iff: CoverageIffClauseSyntax
    initializer: CoverageBinInitializerSyntax
    keyword: Token
    name: Token
    semi: Token
    size: CoverageBinsArraySizeSyntax
    wildcard: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageIffClauseSyntax(SyntaxNode):
    closeParen: Token
    expr: ExpressionSyntax
    iff: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CoverageOptionSetter:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expression(self) -> Expression: ...
    @property
    def isTypeOption(self) -> bool: ...
    @property
    def name(self) -> str: ...

class CoverageOptionSyntax(MemberSyntax):
    expr: ExpressionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CovergroupBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def options(self) -> span[CoverageOptionSetter]: ...

class CovergroupDeclarationSyntax(MemberSyntax):
    covergroup: Token
    endBlockName: NamedBlockClauseSyntax
    endgroup: Token
    event: SyntaxNode
    members: Any
    name: Token
    portList: FunctionPortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class CovergroupType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def body(self) -> CovergroupBodySymbol: ...
    @property
    def coverageEvent(self) -> TimingControl: ...
    @property
    def sampleArguments(self) -> span[FormalArgumentSymbol]: ...

class CoverpointSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def coverageExpr(self) -> Expression: ...
    @property
    def iffExpr(self) -> Expression: ...
    @property
    def options(self) -> span[CoverageOptionSetter]: ...
    @property
    def type(self) -> Any: ...

class CoverpointSyntax(MemberSyntax):
    closeBrace: Token
    coverpoint: Token
    emptySemi: Token
    expr: ExpressionSyntax
    iff: CoverageIffClauseSyntax
    label: NamedLabelSyntax
    members: Any
    openBrace: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class CrossIdBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class CycleDelayControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class DPIExportSyntax(MemberSyntax):
    c_identifier: Token
    equals: Token
    functionOrTask: Token
    keyword: Token
    name: Token
    semi: Token
    specString: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DPIImportSyntax(MemberSyntax):
    c_identifier: Token
    equals: Token
    keyword: Token
    method: FunctionPrototypeSyntax
    property: Token
    semi: Token
    specString: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DataDeclarationSyntax(MemberSyntax):
    declarators: Any
    modifiers: Any
    semi: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DataTypeExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class DataTypeSyntax(ExpressionSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class DeclaratorSyntax(SyntaxNode):
    dimensions: Any
    initializer: EqualsValueClauseSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DeclaredType:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def initializerLocation(self) -> SourceLocation: ...
    @property
    def initializerSyntax(self) -> ExpressionSyntax: ...
    @property
    def isEvaluating(self) -> bool: ...
    @property
    def type(self) -> Type: ...
    @property
    def typeSyntax(self) -> DataTypeSyntax: ...

class DefParamAssignmentSyntax(SyntaxNode):
    name: NameSyntax
    setter: EqualsValueClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DefParamSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def target(self) -> Symbol: ...
    @property
    def value(self) -> ConstantValue: ...

class DefParamSyntax(MemberSyntax):
    assignments: Any
    defparam: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultCaseItemSyntax(CaseItemSyntax):
    clause: SyntaxNode
    colon: Token
    defaultKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultClockingReferenceSyntax(MemberSyntax):
    clocking: Token
    defaultKeyword: Token
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultConfigRuleSyntax(ConfigRuleSyntax):
    defaultKeyword: Token
    liblist: ConfigLiblistSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    defaultKeyword: Token
    sequenceKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultDisableDeclarationSyntax(MemberSyntax):
    defaultKeyword: Token
    disableKeyword: Token
    expr: ExpressionSyntax
    iffKeyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultNetTypeDirectiveSyntax(DirectiveSyntax):
    netType: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultPropertyCaseItemSyntax(PropertyCaseItemSyntax):
    colon: Token
    defaultKeyword: Token
    expr: PropertyExprSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultRsCaseItemSyntax(RsCaseItemSyntax):
    colon: Token
    defaultKeyword: Token
    item: RsProdItemSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefaultSkewItemSyntax(MemberSyntax):
    direction: ClockingDirectionSyntax
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DeferredAssertionSyntax(SyntaxNode):
    finalKeyword: Token
    hash: Token
    zero: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DefineDirectiveSyntax(DirectiveSyntax):
    body: Any
    formalArguments: MacroFormalArgumentListSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Definition:
    def __init__(self, *args, **kwargs) -> None: ...
    def getArticleKindString(self) -> str: ...
    def getKindString(self) -> str: ...
    @property
    def attributes(self) -> Any: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...
    @property
    def defaultNetType(self) -> Any: ...
    @property
    def definitionKind(self) -> DefinitionKind: ...
    @property
    def hierarchicalPath(self) -> str: ...
    @property
    def isInstantiated(self) -> bool: ...
    @property
    def location(self) -> Any: ...
    @property
    def name(self) -> str: ...
    @property
    def scope(self) -> Any: ...
    @property
    def syntax(self) -> Any: ...
    @property
    def timeScale(self) -> Any: ...
    @property
    def unconnectedDrive(self) -> UnconnectedDrive: ...

class DefinitionKind:
    __members__: ClassVar[dict] = ...  # read-only
    Interface: ClassVar[DefinitionKind] = ...
    Module: ClassVar[DefinitionKind] = ...
    Program: ClassVar[DefinitionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Delay3Control(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr1(self) -> Expression: ...
    @property
    def expr2(self) -> Expression: ...
    @property
    def expr3(self) -> Expression: ...

class Delay3Syntax(TimingControlSyntax):
    closeParen: Token
    comma1: Token
    comma2: Token
    delay1: ExpressionSyntax
    delay2: ExpressionSyntax
    delay3: ExpressionSyntax
    hash: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DelayControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class DelaySyntax(TimingControlSyntax):
    delayValue: ExpressionSyntax
    hash: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DelayedSequenceElementSyntax(SyntaxNode):
    closeBracket: Token
    delayVal: ExpressionSyntax
    doubleHash: Token
    expr: SequenceExprSyntax
    op: Token
    openBracket: Token
    range: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DelayedSequenceExprSyntax(SequenceExprSyntax):
    elements: Any
    first: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DelayedTerminalArgSyntax(TimingCheckArgSyntax):
    closeBracket: Token
    expr: ExpressionSyntax
    openBracket: Token
    terminal: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DiagCode:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: DiagSubsystem, arg1: int) -> None: ...
    def getCode(self) -> int: ...
    def getSubsystem(self) -> DiagSubsystem: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: DiagCode) -> bool: ...
    def __hash__(self) -> int: ...
    def __ne__(self, arg0: DiagCode) -> bool: ...

class DiagGroup:
    def __init__(self, arg0: str, arg1: List[DiagCode]) -> None: ...
    def getDiags(self) -> span[DiagCode]: ...
    def getName(self) -> str: ...

class DiagSubsystem:
    __members__: ClassVar[dict] = ...  # read-only
    Compilation: ClassVar[DiagSubsystem] = ...
    ConstEval: ClassVar[DiagSubsystem] = ...
    Declarations: ClassVar[DiagSubsystem] = ...
    Expressions: ClassVar[DiagSubsystem] = ...
    General: ClassVar[DiagSubsystem] = ...
    Invalid: ClassVar[DiagSubsystem] = ...
    Lexer: ClassVar[DiagSubsystem] = ...
    Lookup: ClassVar[DiagSubsystem] = ...
    Meta: ClassVar[DiagSubsystem] = ...
    Numeric: ClassVar[DiagSubsystem] = ...
    Parser: ClassVar[DiagSubsystem] = ...
    Preprocessor: ClassVar[DiagSubsystem] = ...
    Statements: ClassVar[DiagSubsystem] = ...
    SysFuncs: ClassVar[DiagSubsystem] = ...
    Types: ClassVar[DiagSubsystem] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Diagnostic:
    __hash__: ClassVar[None] = ...
    def __init__(self, arg0: DiagCode, arg1: SourceLocation) -> None: ...
    def isError(self) -> bool: ...
    def __eq__(self, arg0: Diagnostic) -> bool: ...
    def __ne__(self, arg0: Diagnostic) -> bool: ...
    @property
    def code(self) -> DiagCode: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def symbol(self) -> Any: ...

class DiagnosticClient:
    def __init__(self, *args, **kwargs) -> None: ...
    def report(self, arg0: ReportedDiagnostic) -> None: ...
    def setEngine(self, arg0: DiagnosticEngine) -> None: ...

class DiagnosticEngine:
    def __init__(self, arg0: SourceManager) -> None: ...
    def addClient(self, arg0) -> None: ...
    def clearClients(self) -> None: ...
    def clearCounts(self) -> None: ...
    @overload
    def clearMappings(self) -> None: ...
    @overload
    def clearMappings(self, arg0: DiagnosticSeverity) -> None: ...
    def findDiagGroup(self, arg0: str) -> DiagGroup: ...
    def findFromOptionName(self, arg0: str) -> span[DiagCode]: ...
    def formatMessage(self, arg0: Diagnostic) -> str: ...
    def getMessage(self, arg0: DiagCode) -> str: ...
    def getOptionName(self, arg0: DiagCode) -> str: ...
    def getSeverity(self, arg0: DiagCode, arg1: SourceLocation) -> DiagnosticSeverity: ...
    def issue(self, arg0: Diagnostic) -> None: ...
    def reportAll(self, *args, **kwargs) -> Any: ...
    def setDefaultWarnings(self) -> None: ...
    def setErrorLimit(self, arg0: int) -> None: ...
    def setErrorsAsFatal(self, arg0: bool) -> None: ...
    def setFatalsAsErrors(self, arg0: bool) -> None: ...
    def setIgnoreAllNotes(self, arg0: bool) -> None: ...
    def setIgnoreAllWarnings(self, arg0: bool) -> None: ...
    @overload
    def setMappingsFromPragmas(self) -> Diagnostics: ...
    @overload
    def setMappingsFromPragmas(self, arg0: BufferID) -> Diagnostics: ...
    def setMessage(self, arg0: DiagCode, arg1: str) -> None: ...
    @overload
    def setSeverity(self, arg0: DiagCode, arg1: DiagnosticSeverity) -> None: ...
    @overload
    def setSeverity(self, arg0: DiagGroup, arg1: DiagnosticSeverity) -> None: ...
    def setWarningOptions(self, arg0: span[str]) -> Diagnostics: ...
    def setWarningsAsErrors(self, arg0: bool) -> None: ...
    @property
    def numErrors(self) -> int: ...
    @property
    def numWarnings(self) -> int: ...
    @property
    def sourceManager(self) -> SourceManager: ...

class DiagnosticSeverity:
    __members__: ClassVar[dict] = ...  # read-only
    Error: ClassVar[DiagnosticSeverity] = ...
    Fatal: ClassVar[DiagnosticSeverity] = ...
    Ignored: ClassVar[DiagnosticSeverity] = ...
    Note: ClassVar[DiagnosticSeverity] = ...
    Warning: ClassVar[DiagnosticSeverity] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Diagnostics:
    def __init__(self) -> None: ...
    @overload
    def add(self, arg0: DiagCode, arg1: SourceLocation) -> Diagnostic: ...
    @overload
    def add(self, arg0: DiagCode, arg1: SourceRange) -> Diagnostic: ...
    @overload
    def add(self, arg0, arg1: DiagCode, arg2: SourceLocation) -> Diagnostic: ...
    @overload
    def add(self, arg0, arg1: DiagCode, arg2: SourceRange) -> Diagnostic: ...
    def sort(self, arg0: SourceManager) -> None: ...
    def __getitem__(self, arg0: int) -> Diagnostic: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...

class Diags:
    AlwaysFFEventControl: ClassVar[DiagCode] = ...  # read-only
    AmbiguousWildcardImport: ClassVar[DiagCode] = ...  # read-only
    AnsiIfacePortDefault: ClassVar[DiagCode] = ...  # read-only
    ArgCannotBeEmpty: ClassVar[DiagCode] = ...  # read-only
    ArgDoesNotExist: ClassVar[DiagCode] = ...  # read-only
    ArrayDimTooLarge: ClassVar[DiagCode] = ...  # read-only
    ArrayLocatorWithClause: ClassVar[DiagCode] = ...  # read-only
    ArrayMethodComparable: ClassVar[DiagCode] = ...  # read-only
    ArrayMethodIntegral: ClassVar[DiagCode] = ...  # read-only
    AssertionArgNeedsRegExpr: ClassVar[DiagCode] = ...  # read-only
    AssertionArgTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    AssertionArgTypeSequence: ClassVar[DiagCode] = ...  # read-only
    AssertionDelayFormalType: ClassVar[DiagCode] = ...  # read-only
    AssertionExprType: ClassVar[DiagCode] = ...  # read-only
    AssertionFuncArg: ClassVar[DiagCode] = ...  # read-only
    AssertionOutputLocalVar: ClassVar[DiagCode] = ...  # read-only
    AssertionPortDirNoLocal: ClassVar[DiagCode] = ...  # read-only
    AssertionPortOutputDefault: ClassVar[DiagCode] = ...  # read-only
    AssertionPortPropOutput: ClassVar[DiagCode] = ...  # read-only
    AssertionPortTypedLValue: ClassVar[DiagCode] = ...  # read-only
    AssignToCHandle: ClassVar[DiagCode] = ...  # read-only
    AssignToNet: ClassVar[DiagCode] = ...  # read-only
    AssignedToLocalBodyParam: ClassVar[DiagCode] = ...  # read-only
    AssignedToLocalPortParam: ClassVar[DiagCode] = ...  # read-only
    AssignmentNotAllowed: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternAssociativeType: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternDynamicDefault: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternDynamicType: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyDupDefault: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyDupName: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyDupValue: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternKeyExpr: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternMissingElements: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternNoContext: ClassVar[DiagCode] = ...  # read-only
    AssignmentPatternNoMember: ClassVar[DiagCode] = ...  # read-only
    AssignmentRequiresParens: ClassVar[DiagCode] = ...  # read-only
    AssignmentToConstVar: ClassVar[DiagCode] = ...  # read-only
    AssociativeWildcardNotAllowed: ClassVar[DiagCode] = ...  # read-only
    AttributesNotAllowed: ClassVar[DiagCode] = ...  # read-only
    AutoFromNonBlockingTiming: ClassVar[DiagCode] = ...  # read-only
    AutoFromNonProcedural: ClassVar[DiagCode] = ...  # read-only
    AutoFromStaticInit: ClassVar[DiagCode] = ...  # read-only
    AutoVarTraced: ClassVar[DiagCode] = ...  # read-only
    AutoVariableHierarchical: ClassVar[DiagCode] = ...  # read-only
    AutomaticNotAllowed: ClassVar[DiagCode] = ...  # read-only
    BadAssignment: ClassVar[DiagCode] = ...  # read-only
    BadAssignmentPatternType: ClassVar[DiagCode] = ...  # read-only
    BadBinaryDigit: ClassVar[DiagCode] = ...  # read-only
    BadBinaryExpression: ClassVar[DiagCode] = ...  # read-only
    BadCastType: ClassVar[DiagCode] = ...  # read-only
    BadConcatExpression: ClassVar[DiagCode] = ...  # read-only
    BadConditionalExpression: ClassVar[DiagCode] = ...  # read-only
    BadConversion: ClassVar[DiagCode] = ...  # read-only
    BadDecimalDigit: ClassVar[DiagCode] = ...  # read-only
    BadDisableSoft: ClassVar[DiagCode] = ...  # read-only
    BadFinishNum: ClassVar[DiagCode] = ...  # read-only
    BadForceNetType: ClassVar[DiagCode] = ...  # read-only
    BadHexDigit: ClassVar[DiagCode] = ...  # read-only
    BadIndexExpression: ClassVar[DiagCode] = ...  # read-only
    BadInstanceArrayRange: ClassVar[DiagCode] = ...  # read-only
    BadIntegerCast: ClassVar[DiagCode] = ...  # read-only
    BadOctalDigit: ClassVar[DiagCode] = ...  # read-only
    BadOpenRange: ClassVar[DiagCode] = ...  # read-only
    BadProceduralAssign: ClassVar[DiagCode] = ...  # read-only
    BadProceduralForce: ClassVar[DiagCode] = ...  # read-only
    BadReplicationExpression: ClassVar[DiagCode] = ...  # read-only
    BadSetMembershipType: ClassVar[DiagCode] = ...  # read-only
    BadSliceType: ClassVar[DiagCode] = ...  # read-only
    BadSolveBefore: ClassVar[DiagCode] = ...  # read-only
    BadStreamCast: ClassVar[DiagCode] = ...  # read-only
    BadStreamContext: ClassVar[DiagCode] = ...  # read-only
    BadStreamExprType: ClassVar[DiagCode] = ...  # read-only
    BadStreamSize: ClassVar[DiagCode] = ...  # read-only
    BadStreamSlice: ClassVar[DiagCode] = ...  # read-only
    BadStreamSourceType: ClassVar[DiagCode] = ...  # read-only
    BadStreamTargetType: ClassVar[DiagCode] = ...  # read-only
    BadStreamWithOrder: ClassVar[DiagCode] = ...  # read-only
    BadStreamWithType: ClassVar[DiagCode] = ...  # read-only
    BadSystemSubroutineArg: ClassVar[DiagCode] = ...  # read-only
    BadTypeParamExpr: ClassVar[DiagCode] = ...  # read-only
    BadUnaryExpression: ClassVar[DiagCode] = ...  # read-only
    BaseConstructorDuplicate: ClassVar[DiagCode] = ...  # read-only
    BaseConstructorNotCalled: ClassVar[DiagCode] = ...  # read-only
    BlockingInAlwaysFF: ClassVar[DiagCode] = ...  # read-only
    BodyForPure: ClassVar[DiagCode] = ...  # read-only
    BodyForPureConstraint: ClassVar[DiagCode] = ...  # read-only
    BodyParamNoInitializer: ClassVar[DiagCode] = ...  # read-only
    CHandleInAssertion: ClassVar[DiagCode] = ...  # read-only
    CannotDeclareType: ClassVar[DiagCode] = ...  # read-only
    CannotIndexScalar: ClassVar[DiagCode] = ...  # read-only
    CantDeclarePortSigned: ClassVar[DiagCode] = ...  # read-only
    CantModifyConst: ClassVar[DiagCode] = ...  # read-only
    CaseGenerateDup: ClassVar[DiagCode] = ...  # read-only
    CaseGenerateEmpty: ClassVar[DiagCode] = ...  # read-only
    CaseGenerateNoBlock: ClassVar[DiagCode] = ...  # read-only
    CaseInsideKeyword: ClassVar[DiagCode] = ...  # read-only
    CaseStatementEmpty: ClassVar[DiagCode] = ...  # read-only
    CastArgSingular: ClassVar[DiagCode] = ...  # read-only
    ChargeWithTriReg: ClassVar[DiagCode] = ...  # read-only
    ClassInheritanceCycle: ClassVar[DiagCode] = ...  # read-only
    ClassMemberInAssertion: ClassVar[DiagCode] = ...  # read-only
    ClockVarAssignConcat: ClassVar[DiagCode] = ...  # read-only
    ClockVarBadTiming: ClassVar[DiagCode] = ...  # read-only
    ClockVarOutputRead: ClassVar[DiagCode] = ...  # read-only
    ClockVarSyncDrive: ClassVar[DiagCode] = ...  # read-only
    ClockVarTargetAssign: ClassVar[DiagCode] = ...  # read-only
    ClockingBlockEventEdge: ClassVar[DiagCode] = ...  # read-only
    ClockingNameEmpty: ClassVar[DiagCode] = ...  # read-only
    ConcatWithStringInt: ClassVar[DiagCode] = ...  # read-only
    ConcurrentAssertActionBlock: ClassVar[DiagCode] = ...  # read-only
    ConstEvalAssertionFailed: ClassVar[DiagCode] = ...  # read-only
    ConstEvalAssociativeElementNotFound: ClassVar[DiagCode] = ...  # read-only
    ConstEvalAssociativeIndexInvalid: ClassVar[DiagCode] = ...  # read-only
    ConstEvalBitsNotFixedSize: ClassVar[DiagCode] = ...  # read-only
    ConstEvalBitstreamCastSize: ClassVar[DiagCode] = ...  # read-only
    ConstEvalCaseItemsNotUnique: ClassVar[DiagCode] = ...  # read-only
    ConstEvalClassType: ClassVar[DiagCode] = ...  # read-only
    ConstEvalCovergroupType: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDPINotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDisableTarget: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDynamicArrayIndex: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDynamicArrayRange: ClassVar[DiagCode] = ...  # read-only
    ConstEvalDynamicToFixedSize: ClassVar[DiagCode] = ...  # read-only
    ConstEvalEmptyQueue: ClassVar[DiagCode] = ...  # read-only
    ConstEvalExceededMaxCallDepth: ClassVar[DiagCode] = ...  # read-only
    ConstEvalExceededMaxSteps: ClassVar[DiagCode] = ...  # read-only
    ConstEvalFunctionArgDirection: ClassVar[DiagCode] = ...  # read-only
    ConstEvalFunctionIdentifiersMustBeLocal: ClassVar[DiagCode] = ...  # read-only
    ConstEvalFunctionInsideGenerate: ClassVar[DiagCode] = ...  # read-only
    ConstEvalHierarchicalName: ClassVar[DiagCode] = ...  # read-only
    ConstEvalIdUsedInCEBeforeDecl: ClassVar[DiagCode] = ...  # read-only
    ConstEvalMethodNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalNoCaseItemsMatched: ClassVar[DiagCode] = ...  # read-only
    ConstEvalNonConstVariable: ClassVar[DiagCode] = ...  # read-only
    ConstEvalParallelBlockNotConst: ClassVar[DiagCode] = ...  # read-only
    ConstEvalParamCycle: ClassVar[DiagCode] = ...  # read-only
    ConstEvalProceduralAssign: ClassVar[DiagCode] = ...  # read-only
    ConstEvalQueueRange: ClassVar[DiagCode] = ...  # read-only
    ConstEvalRandValue: ClassVar[DiagCode] = ...  # read-only
    ConstEvalReplicationCountInvalid: ClassVar[DiagCode] = ...  # read-only
    ConstEvalStaticSkipped: ClassVar[DiagCode] = ...  # read-only
    ConstEvalSubroutineNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalTaggedUnion: ClassVar[DiagCode] = ...  # read-only
    ConstEvalTaskNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstEvalTimedStmtNotConst: ClassVar[DiagCode] = ...  # read-only
    ConstEvalVoidNotConstant: ClassVar[DiagCode] = ...  # read-only
    ConstFunctionPortRequiresRef: ClassVar[DiagCode] = ...  # read-only
    ConstPortNotAllowed: ClassVar[DiagCode] = ...  # read-only
    ConstSysTaskIgnored: ClassVar[DiagCode] = ...  # read-only
    ConstVarNoInitializer: ClassVar[DiagCode] = ...  # read-only
    ConstVarToRef: ClassVar[DiagCode] = ...  # read-only
    ConstraintNotInClass: ClassVar[DiagCode] = ...  # read-only
    ConstraintQualOutOfBlock: ClassVar[DiagCode] = ...  # read-only
    ConstructorOutsideClass: ClassVar[DiagCode] = ...  # read-only
    ConstructorReturnType: ClassVar[DiagCode] = ...  # read-only
    CopyClassTarget: ClassVar[DiagCode] = ...  # read-only
    CouldNotOpenIncludeFile: ClassVar[DiagCode] = ...  # read-only
    CouldNotResolveHierarchicalPath: ClassVar[DiagCode] = ...  # read-only
    CoverCrossItems: ClassVar[DiagCode] = ...  # read-only
    CoverOptionImmutable: ClassVar[DiagCode] = ...  # read-only
    CoverStmtNoFail: ClassVar[DiagCode] = ...  # read-only
    CoverageBinDefSeqSize: ClassVar[DiagCode] = ...  # read-only
    CoverageBinDefaultIgnore: ClassVar[DiagCode] = ...  # read-only
    CoverageBinDefaultWildcard: ClassVar[DiagCode] = ...  # read-only
    CoverageBinTargetName: ClassVar[DiagCode] = ...  # read-only
    CoverageBinTransSize: ClassVar[DiagCode] = ...  # read-only
    CoverageExprVar: ClassVar[DiagCode] = ...  # read-only
    CoverageOptionDup: ClassVar[DiagCode] = ...  # read-only
    CoverageSampleFormal: ClassVar[DiagCode] = ...  # read-only
    CoverageSetType: ClassVar[DiagCode] = ...  # read-only
    CovergroupOutArg: ClassVar[DiagCode] = ...  # read-only
    CycleDelayNonClock: ClassVar[DiagCode] = ...  # read-only
    DPIExportDifferentScope: ClassVar[DiagCode] = ...  # read-only
    DPIExportDuplicate: ClassVar[DiagCode] = ...  # read-only
    DPIExportDuplicateCId: ClassVar[DiagCode] = ...  # read-only
    DPIExportImportedFunc: ClassVar[DiagCode] = ...  # read-only
    DPIExportKindMismatch: ClassVar[DiagCode] = ...  # read-only
    DPIPureArg: ClassVar[DiagCode] = ...  # read-only
    DPIPureReturn: ClassVar[DiagCode] = ...  # read-only
    DPIRefArg: ClassVar[DiagCode] = ...  # read-only
    DPISignatureMismatch: ClassVar[DiagCode] = ...  # read-only
    DPISpecDisallowed: ClassVar[DiagCode] = ...  # read-only
    DecimalDigitMultipleUnknown: ClassVar[DiagCode] = ...  # read-only
    DeclModifierConflict: ClassVar[DiagCode] = ...  # read-only
    DeclModifierOrdering: ClassVar[DiagCode] = ...  # read-only
    DeclarationsAtStart: ClassVar[DiagCode] = ...  # read-only
    DefParamCycle: ClassVar[DiagCode] = ...  # read-only
    DefParamLocal: ClassVar[DiagCode] = ...  # read-only
    DefParamTarget: ClassVar[DiagCode] = ...  # read-only
    DefParamTargetChange: ClassVar[DiagCode] = ...  # read-only
    DeferredAssertAutoRefArg: ClassVar[DiagCode] = ...  # read-only
    DeferredAssertOutArg: ClassVar[DiagCode] = ...  # read-only
    DeferredAssertSysTask: ClassVar[DiagCode] = ...  # read-only
    DeferredDelayMustBeZero: ClassVar[DiagCode] = ...  # read-only
    DefinitionUsedAsType: ClassVar[DiagCode] = ...  # read-only
    DefinitionUsedAsValue: ClassVar[DiagCode] = ...  # read-only
    Delay3NotAllowed: ClassVar[DiagCode] = ...  # read-only
    Delay3OnVar: ClassVar[DiagCode] = ...  # read-only
    Delay3UdpNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DelayNotNumeric: ClassVar[DiagCode] = ...  # read-only
    DelaysNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DigitsLeadingUnderscore: ClassVar[DiagCode] = ...  # read-only
    DimensionIndexInvalid: ClassVar[DiagCode] = ...  # read-only
    DimensionRequiresConstRange: ClassVar[DiagCode] = ...  # read-only
    DirectionOnInterfacePort: ClassVar[DiagCode] = ...  # read-only
    DirectionWithInterfacePort: ClassVar[DiagCode] = ...  # read-only
    DirectiveInsideDesignElement: ClassVar[DiagCode] = ...  # read-only
    DisableIffLocalVar: ClassVar[DiagCode] = ...  # read-only
    DisableIffMatched: ClassVar[DiagCode] = ...  # read-only
    DisallowedPortDefault: ClassVar[DiagCode] = ...  # read-only
    DotOnType: ClassVar[DiagCode] = ...  # read-only
    DriveStrengthHighZ: ClassVar[DiagCode] = ...  # read-only
    DriveStrengthInvalid: ClassVar[DiagCode] = ...  # read-only
    DriveStrengthNotAllowed: ClassVar[DiagCode] = ...  # read-only
    DupInterfaceExternMethod: ClassVar[DiagCode] = ...  # read-only
    DuplicateArgAssignment: ClassVar[DiagCode] = ...  # read-only
    DuplicateAttribute: ClassVar[DiagCode] = ...  # read-only
    DuplicateDeclModifier: ClassVar[DiagCode] = ...  # read-only
    DuplicateDefinition: ClassVar[DiagCode] = ...  # read-only
    DuplicateImport: ClassVar[DiagCode] = ...  # read-only
    DuplicateParamAssignment: ClassVar[DiagCode] = ...  # read-only
    DuplicatePortConnection: ClassVar[DiagCode] = ...  # read-only
    DuplicateQualifier: ClassVar[DiagCode] = ...  # read-only
    DuplicateWildcardPortConnection: ClassVar[DiagCode] = ...  # read-only
    DynamicDimensionIndex: ClassVar[DiagCode] = ...  # read-only
    DynamicNotProcedural: ClassVar[DiagCode] = ...  # read-only
    EmbeddedNull: ClassVar[DiagCode] = ...  # read-only
    EmptyArgNotAllowed: ClassVar[DiagCode] = ...  # read-only
    EmptyAssignmentPattern: ClassVar[DiagCode] = ...  # read-only
    EmptyBody: ClassVar[DiagCode] = ...  # read-only
    EmptyConcatNotAllowed: ClassVar[DiagCode] = ...  # read-only
    EmptyMember: ClassVar[DiagCode] = ...  # read-only
    EmptyStatement: ClassVar[DiagCode] = ...  # read-only
    EmptyUdpPort: ClassVar[DiagCode] = ...  # read-only
    EndNameMismatch: ClassVar[DiagCode] = ...  # read-only
    EndNameNotEmpty: ClassVar[DiagCode] = ...  # read-only
    EnumIncrementUnknown: ClassVar[DiagCode] = ...  # read-only
    EnumRangeLiteral: ClassVar[DiagCode] = ...  # read-only
    EnumRangeMultiDimensional: ClassVar[DiagCode] = ...  # read-only
    EnumValueDuplicate: ClassVar[DiagCode] = ...  # read-only
    EnumValueOutOfRange: ClassVar[DiagCode] = ...  # read-only
    EnumValueOverflow: ClassVar[DiagCode] = ...  # read-only
    EnumValueSizeMismatch: ClassVar[DiagCode] = ...  # read-only
    EnumValueUnknownBits: ClassVar[DiagCode] = ...  # read-only
    ErrorTask: ClassVar[DiagCode] = ...  # read-only
    EscapedWhitespace: ClassVar[DiagCode] = ...  # read-only
    EventExprAssertionArg: ClassVar[DiagCode] = ...  # read-only
    EventExpressionConstant: ClassVar[DiagCode] = ...  # read-only
    EventExpressionFuncArg: ClassVar[DiagCode] = ...  # read-only
    ExceededMaxIncludeDepth: ClassVar[DiagCode] = ...  # read-only
    ExpectedAnsiPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedArgument: ClassVar[DiagCode] = ...  # read-only
    ExpectedAssertionItemPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedAssignmentKey: ClassVar[DiagCode] = ...  # read-only
    ExpectedAttribute: ClassVar[DiagCode] = ...  # read-only
    ExpectedCaseItem: ClassVar[DiagCode] = ...  # read-only
    ExpectedClassPropertyName: ClassVar[DiagCode] = ...  # read-only
    ExpectedClockingSkew: ClassVar[DiagCode] = ...  # read-only
    ExpectedClosingQuote: ClassVar[DiagCode] = ...  # read-only
    ExpectedConditionalPattern: ClassVar[DiagCode] = ...  # read-only
    ExpectedConstraintName: ClassVar[DiagCode] = ...  # read-only
    ExpectedContinuousAssignment: ClassVar[DiagCode] = ...  # read-only
    ExpectedDPISpecString: ClassVar[DiagCode] = ...  # read-only
    ExpectedDeclarator: ClassVar[DiagCode] = ...  # read-only
    ExpectedDiagPragmaArg: ClassVar[DiagCode] = ...  # read-only
    ExpectedDiagPragmaLevel: ClassVar[DiagCode] = ...  # read-only
    ExpectedDistItem: ClassVar[DiagCode] = ...  # read-only
    ExpectedDriveStrength: ClassVar[DiagCode] = ...  # read-only
    ExpectedEdgeDescriptor: ClassVar[DiagCode] = ...  # read-only
    ExpectedEnumBase: ClassVar[DiagCode] = ...  # read-only
    ExpectedExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedForInitializer: ClassVar[DiagCode] = ...  # read-only
    ExpectedFunctionPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedFunctionPortList: ClassVar[DiagCode] = ...  # read-only
    ExpectedGenvarIterVar: ClassVar[DiagCode] = ...  # read-only
    ExpectedHierarchicalInstantiation: ClassVar[DiagCode] = ...  # read-only
    ExpectedIdentifier: ClassVar[DiagCode] = ...  # read-only
    ExpectedIfOrCase: ClassVar[DiagCode] = ...  # read-only
    ExpectedImportExport: ClassVar[DiagCode] = ...  # read-only
    ExpectedIncludeFileName: ClassVar[DiagCode] = ...  # read-only
    ExpectedIntegerBaseAfterSigned: ClassVar[DiagCode] = ...  # read-only
    ExpectedIntegerLiteral: ClassVar[DiagCode] = ...  # read-only
    ExpectedInterfaceClassName: ClassVar[DiagCode] = ...  # read-only
    ExpectedIterationExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedIteratorName: ClassVar[DiagCode] = ...  # read-only
    ExpectedMacroArgs: ClassVar[DiagCode] = ...  # read-only
    ExpectedMacroStringifyEnd: ClassVar[DiagCode] = ...  # read-only
    ExpectedMember: ClassVar[DiagCode] = ...  # read-only
    ExpectedModOrVarName: ClassVar[DiagCode] = ...  # read-only
    ExpectedModportPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedModuleInstance: ClassVar[DiagCode] = ...  # read-only
    ExpectedModuleName: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetDelay: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetStrength: ClassVar[DiagCode] = ...  # read-only
    ExpectedNetType: ClassVar[DiagCode] = ...  # read-only
    ExpectedNonAnsiPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedOpenRangeElement: ClassVar[DiagCode] = ...  # read-only
    ExpectedPackageImport: ClassVar[DiagCode] = ...  # read-only
    ExpectedParameterPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedPathOp: ClassVar[DiagCode] = ...  # read-only
    ExpectedPattern: ClassVar[DiagCode] = ...  # read-only
    ExpectedPortConnection: ClassVar[DiagCode] = ...  # read-only
    ExpectedPortList: ClassVar[DiagCode] = ...  # read-only
    ExpectedPragmaExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedPragmaName: ClassVar[DiagCode] = ...  # read-only
    ExpectedProtectArg: ClassVar[DiagCode] = ...  # read-only
    ExpectedProtectKeyword: ClassVar[DiagCode] = ...  # read-only
    ExpectedRsRule: ClassVar[DiagCode] = ...  # read-only
    ExpectedSampleKeyword: ClassVar[DiagCode] = ...  # read-only
    ExpectedScopeOrAssert: ClassVar[DiagCode] = ...  # read-only
    ExpectedStatement: ClassVar[DiagCode] = ...  # read-only
    ExpectedStreamExpression: ClassVar[DiagCode] = ...  # read-only
    ExpectedStringLiteral: ClassVar[DiagCode] = ...  # read-only
    ExpectedSubroutineName: ClassVar[DiagCode] = ...  # read-only
    ExpectedTimeLiteral: ClassVar[DiagCode] = ...  # read-only
    ExpectedToken: ClassVar[DiagCode] = ...  # read-only
    ExpectedUdpPort: ClassVar[DiagCode] = ...  # read-only
    ExpectedUdpSymbol: ClassVar[DiagCode] = ...  # read-only
    ExpectedVariableAssignment: ClassVar[DiagCode] = ...  # read-only
    ExpectedVariableName: ClassVar[DiagCode] = ...  # read-only
    ExpectedVectorDigits: ClassVar[DiagCode] = ...  # read-only
    ExprMustBeIntegral: ClassVar[DiagCode] = ...  # read-only
    ExprNotConstraint: ClassVar[DiagCode] = ...  # read-only
    ExprNotStatement: ClassVar[DiagCode] = ...  # read-only
    ExpressionNotAssignable: ClassVar[DiagCode] = ...  # read-only
    ExpressionNotCallable: ClassVar[DiagCode] = ...  # read-only
    ExtendClassFromIface: ClassVar[DiagCode] = ...  # read-only
    ExtendIfaceFromClass: ClassVar[DiagCode] = ...  # read-only
    ExternFuncForkJoin: ClassVar[DiagCode] = ...  # read-only
    ExtraPragmaArgs: ClassVar[DiagCode] = ...  # read-only
    ExtraProtectEnd: ClassVar[DiagCode] = ...  # read-only
    FatalTask: ClassVar[DiagCode] = ...  # read-only
    ForeachDynamicDimAfterSkipped: ClassVar[DiagCode] = ...  # read-only
    ForeachWildcardIndex: ClassVar[DiagCode] = ...  # read-only
    ForkJoinAlwaysComb: ClassVar[DiagCode] = ...  # read-only
    FormatEmptyArg: ClassVar[DiagCode] = ...  # read-only
    FormatMismatchedType: ClassVar[DiagCode] = ...  # read-only
    FormatMultibitStrength: ClassVar[DiagCode] = ...  # read-only
    FormatNoArgument: ClassVar[DiagCode] = ...  # read-only
    FormatRealInt: ClassVar[DiagCode] = ...  # read-only
    FormatSpecifierInvalidWidth: ClassVar[DiagCode] = ...  # read-only
    FormatSpecifierNotFloat: ClassVar[DiagCode] = ...  # read-only
    FormatSpecifierWidthNotAllowed: ClassVar[DiagCode] = ...  # read-only
    FormatTooManyArgs: ClassVar[DiagCode] = ...  # read-only
    FormatUnspecifiedType: ClassVar[DiagCode] = ...  # read-only
    ForwardTypedefDoesNotMatch: ClassVar[DiagCode] = ...  # read-only
    ForwardTypedefVisibility: ClassVar[DiagCode] = ...  # read-only
    GenericClassScopeResolution: ClassVar[DiagCode] = ...  # read-only
    GenvarDuplicate: ClassVar[DiagCode] = ...  # read-only
    GenvarUnknownBits: ClassVar[DiagCode] = ...  # read-only
    GlobalClockEventExpr: ClassVar[DiagCode] = ...  # read-only
    GlobalClockingEmpty: ClassVar[DiagCode] = ...  # read-only
    GlobalClockingGenerate: ClassVar[DiagCode] = ...  # read-only
    GlobalSampledValueAssertionExpr: ClassVar[DiagCode] = ...  # read-only
    GlobalSampledValueNested: ClassVar[DiagCode] = ...  # read-only
    IfaceExtendIncomplete: ClassVar[DiagCode] = ...  # read-only
    IfaceExtendTypeParam: ClassVar[DiagCode] = ...  # read-only
    IfaceImportExportTarget: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodHidden: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodNoImpl: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodNotExtern: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodNotVirtual: ClassVar[DiagCode] = ...  # read-only
    IfaceMethodPure: ClassVar[DiagCode] = ...  # read-only
    IfaceNameConflict: ClassVar[DiagCode] = ...  # read-only
    IfacePortInExpr: ClassVar[DiagCode] = ...  # read-only
    IgnoredMacroPaste: ClassVar[DiagCode] = ...  # read-only
    IgnoredSlice: ClassVar[DiagCode] = ...  # read-only
    ImplementNonIface: ClassVar[DiagCode] = ...  # read-only
    ImplicitConvert: ClassVar[DiagCode] = ...  # read-only
    ImplicitNamedPortNotFound: ClassVar[DiagCode] = ...  # read-only
    ImplicitNamedPortTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    ImplicitNetPortNoDefault: ClassVar[DiagCode] = ...  # read-only
    ImplicitNotAllowed: ClassVar[DiagCode] = ...  # read-only
    ImportNameCollision: ClassVar[DiagCode] = ...  # read-only
    InOutDefaultSkew: ClassVar[DiagCode] = ...  # read-only
    InOutPortCannotBeVariable: ClassVar[DiagCode] = ...  # read-only
    InOutUWireConn: ClassVar[DiagCode] = ...  # read-only
    InOutUWirePort: ClassVar[DiagCode] = ...  # read-only
    InOutVarPortConn: ClassVar[DiagCode] = ...  # read-only
    IncDecNotAllowed: ClassVar[DiagCode] = ...  # read-only
    IndexOOB: ClassVar[DiagCode] = ...  # read-only
    IndexValueInvalid: ClassVar[DiagCode] = ...  # read-only
    InequivalentUniquenessTypes: ClassVar[DiagCode] = ...  # read-only
    InfinitelyRecursiveHierarchy: ClassVar[DiagCode] = ...  # read-only
    InfoTask: ClassVar[DiagCode] = ...  # read-only
    InheritFromAbstract: ClassVar[DiagCode] = ...  # read-only
    InheritFromAbstractConstraint: ClassVar[DiagCode] = ...  # read-only
    InitializerRequired: ClassVar[DiagCode] = ...  # read-only
    InputPortAssign: ClassVar[DiagCode] = ...  # read-only
    InputPortCoercion: ClassVar[DiagCode] = ...  # read-only
    InstanceArrayEndianMismatch: ClassVar[DiagCode] = ...  # read-only
    InstanceMissingParens: ClassVar[DiagCode] = ...  # read-only
    InstanceNameRequired: ClassVar[DiagCode] = ...  # read-only
    InstanceWithDelay: ClassVar[DiagCode] = ...  # read-only
    InstanceWithStrength: ClassVar[DiagCode] = ...  # read-only
    InterconnectDelaySyntax: ClassVar[DiagCode] = ...  # read-only
    InterconnectInitializer: ClassVar[DiagCode] = ...  # read-only
    InterconnectMultiPort: ClassVar[DiagCode] = ...  # read-only
    InterconnectPortVar: ClassVar[DiagCode] = ...  # read-only
    InterconnectReference: ClassVar[DiagCode] = ...  # read-only
    InterconnectTypeSyntax: ClassVar[DiagCode] = ...  # read-only
    InterfacePortInvalidExpression: ClassVar[DiagCode] = ...  # read-only
    InterfacePortNotConnected: ClassVar[DiagCode] = ...  # read-only
    InterfacePortTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    InvalidAccessDotColon: ClassVar[DiagCode] = ...  # read-only
    InvalidArgumentExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidArrayElemType: ClassVar[DiagCode] = ...  # read-only
    InvalidArraySize: ClassVar[DiagCode] = ...  # read-only
    InvalidAssociativeIndexType: ClassVar[DiagCode] = ...  # read-only
    InvalidBinsMatches: ClassVar[DiagCode] = ...  # read-only
    InvalidBinsTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidBlockEventTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidClassAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidClockingSignal: ClassVar[DiagCode] = ...  # read-only
    InvalidCommaInPropExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidConstraintQualifier: ClassVar[DiagCode] = ...  # read-only
    InvalidConstructorAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidCoverageOption: ClassVar[DiagCode] = ...  # read-only
    InvalidDPIArgType: ClassVar[DiagCode] = ...  # read-only
    InvalidDPICIdentifier: ClassVar[DiagCode] = ...  # read-only
    InvalidDPIReturnType: ClassVar[DiagCode] = ...  # read-only
    InvalidDeferredAssertAction: ClassVar[DiagCode] = ...  # read-only
    InvalidDelayValue: ClassVar[DiagCode] = ...  # read-only
    InvalidDimensionRange: ClassVar[DiagCode] = ...  # read-only
    InvalidDisableTarget: ClassVar[DiagCode] = ...  # read-only
    InvalidDistExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidEdgeDescriptor: ClassVar[DiagCode] = ...  # read-only
    InvalidEncodingByte: ClassVar[DiagCode] = ...  # read-only
    InvalidEnumBase: ClassVar[DiagCode] = ...  # read-only
    InvalidEventExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidForInitializer: ClassVar[DiagCode] = ...  # read-only
    InvalidForStepExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidGenvarIterExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidHexEscapeCode: ClassVar[DiagCode] = ...  # read-only
    InvalidInstanceForParent: ClassVar[DiagCode] = ...  # read-only
    InvalidLineDirectiveLevel: ClassVar[DiagCode] = ...  # read-only
    InvalidMacroName: ClassVar[DiagCode] = ...  # read-only
    InvalidMatchItem: ClassVar[DiagCode] = ...  # read-only
    InvalidMemberAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidMethodOverride: ClassVar[DiagCode] = ...  # read-only
    InvalidMethodQualifier: ClassVar[DiagCode] = ...  # read-only
    InvalidModportAccess: ClassVar[DiagCode] = ...  # read-only
    InvalidNGateCount: ClassVar[DiagCode] = ...  # read-only
    InvalidNetType: ClassVar[DiagCode] = ...  # read-only
    InvalidPackageDecl: ClassVar[DiagCode] = ...  # read-only
    InvalidParamOverrideOpt: ClassVar[DiagCode] = ...  # read-only
    InvalidPortType: ClassVar[DiagCode] = ...  # read-only
    InvalidPragmaNumber: ClassVar[DiagCode] = ...  # read-only
    InvalidPragmaViewport: ClassVar[DiagCode] = ...  # read-only
    InvalidPrimInstanceForParent: ClassVar[DiagCode] = ...  # read-only
    InvalidPrimitivePortConn: ClassVar[DiagCode] = ...  # read-only
    InvalidPropertyIndex: ClassVar[DiagCode] = ...  # read-only
    InvalidPropertyQualifier: ClassVar[DiagCode] = ...  # read-only
    InvalidPropertyRange: ClassVar[DiagCode] = ...  # read-only
    InvalidPullStrength: ClassVar[DiagCode] = ...  # read-only
    InvalidQualifierForConstructor: ClassVar[DiagCode] = ...  # read-only
    InvalidQualifierForIfaceMember: ClassVar[DiagCode] = ...  # read-only
    InvalidQualifierForMember: ClassVar[DiagCode] = ...  # read-only
    InvalidRandType: ClassVar[DiagCode] = ...  # read-only
    InvalidRandomizeOverride: ClassVar[DiagCode] = ...  # read-only
    InvalidRefArg: ClassVar[DiagCode] = ...  # read-only
    InvalidRepeatRange: ClassVar[DiagCode] = ...  # read-only
    InvalidScopeIndexExpression: ClassVar[DiagCode] = ...  # read-only
    InvalidSignalEventInSeq: ClassVar[DiagCode] = ...  # read-only
    InvalidStringArg: ClassVar[DiagCode] = ...  # read-only
    InvalidSuperNew: ClassVar[DiagCode] = ...  # read-only
    InvalidSyntaxInEventExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidThisHandle: ClassVar[DiagCode] = ...  # read-only
    InvalidTimeScalePrecision: ClassVar[DiagCode] = ...  # read-only
    InvalidTimeScaleSpecifier: ClassVar[DiagCode] = ...  # read-only
    InvalidTopModule: ClassVar[DiagCode] = ...  # read-only
    InvalidUTF8Seq: ClassVar[DiagCode] = ...  # read-only
    InvalidUnionMember: ClassVar[DiagCode] = ...  # read-only
    InvalidUniquenessExpr: ClassVar[DiagCode] = ...  # read-only
    InvalidUserDefinedNetType: ClassVar[DiagCode] = ...  # read-only
    IteratorArgsWithoutWithClause: ClassVar[DiagCode] = ...  # read-only
    LabelAndName: ClassVar[DiagCode] = ...  # read-only
    LetHierarchical: ClassVar[DiagCode] = ...  # read-only
    LifetimeForPrototype: ClassVar[DiagCode] = ...  # read-only
    LiteralSizeIsZero: ClassVar[DiagCode] = ...  # read-only
    LiteralSizeTooLarge: ClassVar[DiagCode] = ...  # read-only
    LocalFormalVarMultiAssign: ClassVar[DiagCode] = ...  # read-only
    LocalMemberAccess: ClassVar[DiagCode] = ...  # read-only
    LocalNotAllowed: ClassVar[DiagCode] = ...  # read-only
    LocalParamNoInitializer: ClassVar[DiagCode] = ...  # read-only
    LocalVarEventExpr: ClassVar[DiagCode] = ...  # read-only
    LocalVarMatchItem: ClassVar[DiagCode] = ...  # read-only
    LocalVarOutputEmptyMatch: ClassVar[DiagCode] = ...  # read-only
    LocalVarTypeRequired: ClassVar[DiagCode] = ...  # read-only
    LoopVarShadowsArray: ClassVar[DiagCode] = ...  # read-only
    MacroOpsOutsideDefinition: ClassVar[DiagCode] = ...  # read-only
    MacroTokensAfterPragmaProtect: ClassVar[DiagCode] = ...  # read-only
    MatchItemsAdmitEmpty: ClassVar[DiagCode] = ...  # read-only
    MaxGenerateStepsExceeded: ClassVar[DiagCode] = ...  # read-only
    MaxInstanceArrayExceeded: ClassVar[DiagCode] = ...  # read-only
    MaxInstanceDepthExceeded: ClassVar[DiagCode] = ...  # read-only
    MemberDefinitionBeforeClass: ClassVar[DiagCode] = ...  # read-only
    MethodArgCountMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgDefaultMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgDirectionMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgNameMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodArgNoDefault: ClassVar[DiagCode] = ...  # read-only
    MethodArgTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodKindMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodReturnMismatch: ClassVar[DiagCode] = ...  # read-only
    MethodReturnTypeScoped: ClassVar[DiagCode] = ...  # read-only
    MethodStaticLifetime: ClassVar[DiagCode] = ...  # read-only
    MismatchStaticConstraint: ClassVar[DiagCode] = ...  # read-only
    MismatchedEndKeywordsDirective: ClassVar[DiagCode] = ...  # read-only
    MismatchedTimeScales: ClassVar[DiagCode] = ...  # read-only
    MismatchedUserDefPortConn: ClassVar[DiagCode] = ...  # read-only
    MismatchedUserDefPortDir: ClassVar[DiagCode] = ...  # read-only
    MisplacedDirectiveChar: ClassVar[DiagCode] = ...  # read-only
    MisplacedTrailingSeparator: ClassVar[DiagCode] = ...  # read-only
    MissingConstraintBlock: ClassVar[DiagCode] = ...  # read-only
    MissingEndIfDirective: ClassVar[DiagCode] = ...  # read-only
    MissingExponentDigits: ClassVar[DiagCode] = ...  # read-only
    MissingExportImpl: ClassVar[DiagCode] = ...  # read-only
    MissingExternImpl: ClassVar[DiagCode] = ...  # read-only
    MissingFormatSpecifier: ClassVar[DiagCode] = ...  # read-only
    MissingFractionalDigits: ClassVar[DiagCode] = ...  # read-only
    MissingInvocationParens: ClassVar[DiagCode] = ...  # read-only
    MissingModportPortDirection: ClassVar[DiagCode] = ...  # read-only
    MissingPortIODeclaration: ClassVar[DiagCode] = ...  # read-only
    MissingReturnValue: ClassVar[DiagCode] = ...  # read-only
    MissingReturnValueProd: ClassVar[DiagCode] = ...  # read-only
    MixedVarAssigns: ClassVar[DiagCode] = ...  # read-only
    MixingOrderedAndNamedArgs: ClassVar[DiagCode] = ...  # read-only
    MixingOrderedAndNamedParams: ClassVar[DiagCode] = ...  # read-only
    MixingOrderedAndNamedPorts: ClassVar[DiagCode] = ...  # read-only
    MixingSubroutinePortKinds: ClassVar[DiagCode] = ...  # read-only
    ModportConnMismatch: ClassVar[DiagCode] = ...  # read-only
    MultipleAlwaysAssigns: ClassVar[DiagCode] = ...  # read-only
    MultipleContAssigns: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultCases: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultClocking: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultDisable: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultInputSkew: ClassVar[DiagCode] = ...  # read-only
    MultipleDefaultOutputSkew: ClassVar[DiagCode] = ...  # read-only
    MultipleGenerateDefaultCases: ClassVar[DiagCode] = ...  # read-only
    MultipleGlobalClocking: ClassVar[DiagCode] = ...  # read-only
    MultipleUDNTDrivers: ClassVar[DiagCode] = ...  # read-only
    MultipleUWireDrivers: ClassVar[DiagCode] = ...  # read-only
    NTResolveArgModify: ClassVar[DiagCode] = ...  # read-only
    NTResolveClass: ClassVar[DiagCode] = ...  # read-only
    NTResolveReturn: ClassVar[DiagCode] = ...  # read-only
    NTResolveSingleArg: ClassVar[DiagCode] = ...  # read-only
    NTResolveTask: ClassVar[DiagCode] = ...  # read-only
    NTResolveUserDef: ClassVar[DiagCode] = ...  # read-only
    NameListWithScopeRandomize: ClassVar[DiagCode] = ...  # read-only
    NamedArgNotAllowed: ClassVar[DiagCode] = ...  # read-only
    NestedBlockComment: ClassVar[DiagCode] = ...  # read-only
    NestedDisableIff: ClassVar[DiagCode] = ...  # read-only
    NestedIface: ClassVar[DiagCode] = ...  # read-only
    NestedNonStaticClassMethod: ClassVar[DiagCode] = ...  # read-only
    NestedNonStaticClassProperty: ClassVar[DiagCode] = ...  # read-only
    NestedProtectBegin: ClassVar[DiagCode] = ...  # read-only
    NetInconsistent: ClassVar[DiagCode] = ...  # read-only
    NetRangeInconsistent: ClassVar[DiagCode] = ...  # read-only
    NewArrayTarget: ClassVar[DiagCode] = ...  # read-only
    NewClassTarget: ClassVar[DiagCode] = ...  # read-only
    NewInterfaceClass: ClassVar[DiagCode] = ...  # read-only
    NewKeywordQualified: ClassVar[DiagCode] = ...  # read-only
    NewVirtualClass: ClassVar[DiagCode] = ...  # read-only
    NoCommonComparisonType: ClassVar[DiagCode] = ...  # read-only
    NoConstraintBody: ClassVar[DiagCode] = ...  # read-only
    NoDeclInClass: ClassVar[DiagCode] = ...  # read-only
    NoDefaultClocking: ClassVar[DiagCode] = ...  # read-only
    NoDefaultSpecialization: ClassVar[DiagCode] = ...  # read-only
    NoGlobalClocking: ClassVar[DiagCode] = ...  # read-only
    NoImplicitConversion: ClassVar[DiagCode] = ...  # read-only
    NoLabelOnSemicolon: ClassVar[DiagCode] = ...  # read-only
    NoMemberImplFound: ClassVar[DiagCode] = ...  # read-only
    NoTopModules: ClassVar[DiagCode] = ...  # read-only
    NonIntegralConstraintExpr: ClassVar[DiagCode] = ...  # read-only
    NonIntegralConstraintLiteral: ClassVar[DiagCode] = ...  # read-only
    NonIntegralCoverageExpr: ClassVar[DiagCode] = ...  # read-only
    NonPrintableChar: ClassVar[DiagCode] = ...  # read-only
    NonProceduralFuncArg: ClassVar[DiagCode] = ...  # read-only
    NonStandardGenBlock: ClassVar[DiagCode] = ...  # read-only
    NonStaticClassMethod: ClassVar[DiagCode] = ...  # read-only
    NonStaticClassProperty: ClassVar[DiagCode] = ...  # read-only
    NonblockingAssignmentToAuto: ClassVar[DiagCode] = ...  # read-only
    NonblockingInFinal: ClassVar[DiagCode] = ...  # read-only
    NonstandardDist: ClassVar[DiagCode] = ...  # read-only
    NonstandardEscapeCode: ClassVar[DiagCode] = ...  # read-only
    NonstandardForeach: ClassVar[DiagCode] = ...  # read-only
    NonstandardSysFunc: ClassVar[DiagCode] = ...  # read-only
    NotAClass: ClassVar[DiagCode] = ...  # read-only
    NotAClockingBlock: ClassVar[DiagCode] = ...  # read-only
    NotAGenericClass: ClassVar[DiagCode] = ...  # read-only
    NotAGenvar: ClassVar[DiagCode] = ...  # read-only
    NotAHierarchicalScope: ClassVar[DiagCode] = ...  # read-only
    NotAModport: ClassVar[DiagCode] = ...  # read-only
    NotAProduction: ClassVar[DiagCode] = ...  # read-only
    NotASubroutine: ClassVar[DiagCode] = ...  # read-only
    NotAType: ClassVar[DiagCode] = ...  # read-only
    NotAValue: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInCU: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInChecker: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInClass: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInClocking: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInGenerate: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInIfaceClass: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInInterface: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInModport: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInModule: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInPackage: ClassVar[DiagCode] = ...  # read-only
    NotAllowedInProgram: ClassVar[DiagCode] = ...  # read-only
    NotAnArray: ClassVar[DiagCode] = ...  # read-only
    NotAnEvent: ClassVar[DiagCode] = ...  # read-only
    NotAnInterface: ClassVar[DiagCode] = ...  # read-only
    NotAnInterfaceOrPort: ClassVar[DiagCode] = ...  # read-only
    NotBooleanConvertible: ClassVar[DiagCode] = ...  # read-only
    NotEnoughMacroArgs: ClassVar[DiagCode] = ...  # read-only
    NotYetSupported: ClassVar[DiagCode] = ...  # read-only
    NoteAssignedHere: ClassVar[DiagCode] = ...  # read-only
    NoteComparisonReduces: ClassVar[DiagCode] = ...  # read-only
    NoteDeclarationHere: ClassVar[DiagCode] = ...  # read-only
    NoteDirectiveHere: ClassVar[DiagCode] = ...  # read-only
    NoteDrivenHere: ClassVar[DiagCode] = ...  # read-only
    NoteExpandedHere: ClassVar[DiagCode] = ...  # read-only
    NoteFromHere2: ClassVar[DiagCode] = ...  # read-only
    NoteImportedFrom: ClassVar[DiagCode] = ...  # read-only
    NoteInCallTo: ClassVar[DiagCode] = ...  # read-only
    NoteOriginalAssign: ClassVar[DiagCode] = ...  # read-only
    NotePreviousDefinition: ClassVar[DiagCode] = ...  # read-only
    NotePreviousMatch: ClassVar[DiagCode] = ...  # read-only
    NotePreviousUsage: ClassVar[DiagCode] = ...  # read-only
    NoteReferencedHere: ClassVar[DiagCode] = ...  # read-only
    NoteSkippingFrames: ClassVar[DiagCode] = ...  # read-only
    NoteToMatchThis: ClassVar[DiagCode] = ...  # read-only
    NoteWhileExpanding: ClassVar[DiagCode] = ...  # read-only
    NullPortExpression: ClassVar[DiagCode] = ...  # read-only
    OctalEscapeCodeTooBig: ClassVar[DiagCode] = ...  # read-only
    OpenRangeUnbounded: ClassVar[DiagCode] = ...  # read-only
    OutRefFuncConstraint: ClassVar[DiagCode] = ...  # read-only
    OutputPortCoercion: ClassVar[DiagCode] = ...  # read-only
    PackageNetInit: ClassVar[DiagCode] = ...  # read-only
    PackedArrayNotIntegral: ClassVar[DiagCode] = ...  # read-only
    PackedArrayTooLarge: ClassVar[DiagCode] = ...  # read-only
    PackedDimsOnPredefinedType: ClassVar[DiagCode] = ...  # read-only
    PackedDimsOnUnpacked: ClassVar[DiagCode] = ...  # read-only
    PackedDimsRequireFullRange: ClassVar[DiagCode] = ...  # read-only
    PackedMemberHasInitializer: ClassVar[DiagCode] = ...  # read-only
    PackedMemberNotIntegral: ClassVar[DiagCode] = ...  # read-only
    PackedUnionWidthMismatch: ClassVar[DiagCode] = ...  # read-only
    ParamHasNoValue: ClassVar[DiagCode] = ...  # read-only
    ParameterDoesNotExist: ClassVar[DiagCode] = ...  # read-only
    ParseTreeTooDeep: ClassVar[DiagCode] = ...  # read-only
    PastNumTicksInvalid: ClassVar[DiagCode] = ...  # read-only
    PatternStructTooFew: ClassVar[DiagCode] = ...  # read-only
    PatternStructTooMany: ClassVar[DiagCode] = ...  # read-only
    PatternStructType: ClassVar[DiagCode] = ...  # read-only
    PatternTaggedType: ClassVar[DiagCode] = ...  # read-only
    PlaRangeInAscendingOrder: ClassVar[DiagCode] = ...  # read-only
    PointlessVoidCast: ClassVar[DiagCode] = ...  # read-only
    PortConcatInOut: ClassVar[DiagCode] = ...  # read-only
    PortConcatRef: ClassVar[DiagCode] = ...  # read-only
    PortConnArrayMismatch: ClassVar[DiagCode] = ...  # read-only
    PortConnDimensionsMismatch: ClassVar[DiagCode] = ...  # read-only
    PortDeclDimensionsMismatch: ClassVar[DiagCode] = ...  # read-only
    PortDeclInANSIModule: ClassVar[DiagCode] = ...  # read-only
    PortDoesNotExist: ClassVar[DiagCode] = ...  # read-only
    PortTypeNotInterfaceOrData: ClassVar[DiagCode] = ...  # read-only
    PrimitiveAnsiMix: ClassVar[DiagCode] = ...  # read-only
    PrimitiveDupInitial: ClassVar[DiagCode] = ...  # read-only
    PrimitiveDupOutput: ClassVar[DiagCode] = ...  # read-only
    PrimitiveInitVal: ClassVar[DiagCode] = ...  # read-only
    PrimitiveInitialInComb: ClassVar[DiagCode] = ...  # read-only
    PrimitiveOutputFirst: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortCountWrong: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortDup: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortMissing: ClassVar[DiagCode] = ...  # read-only
    PrimitivePortUnknown: ClassVar[DiagCode] = ...  # read-only
    PrimitiveRegDup: ClassVar[DiagCode] = ...  # read-only
    PrimitiveRegInput: ClassVar[DiagCode] = ...  # read-only
    PrimitiveTwoPorts: ClassVar[DiagCode] = ...  # read-only
    PrimitiveWrongInitial: ClassVar[DiagCode] = ...  # read-only
    PropAbortLocalVar: ClassVar[DiagCode] = ...  # read-only
    PropAbortMatched: ClassVar[DiagCode] = ...  # read-only
    PropExprInSequence: ClassVar[DiagCode] = ...  # read-only
    PropInstanceRepetition: ClassVar[DiagCode] = ...  # read-only
    PropertyLhsInvalid: ClassVar[DiagCode] = ...  # read-only
    PropertyPortInLet: ClassVar[DiagCode] = ...  # read-only
    PropertyPortInSeq: ClassVar[DiagCode] = ...  # read-only
    ProtectArgList: ClassVar[DiagCode] = ...  # read-only
    ProtectEncodingBytes: ClassVar[DiagCode] = ...  # read-only
    ProtectedEnvelope: ClassVar[DiagCode] = ...  # read-only
    ProtectedMemberAccess: ClassVar[DiagCode] = ...  # read-only
    PullStrengthHighZ: ClassVar[DiagCode] = ...  # read-only
    PureConstraintInAbstract: ClassVar[DiagCode] = ...  # read-only
    PureInAbstract: ClassVar[DiagCode] = ...  # read-only
    PureRequiresVirtual: ClassVar[DiagCode] = ...  # read-only
    QualifierConflict: ClassVar[DiagCode] = ...  # read-only
    QualifierNotFirst: ClassVar[DiagCode] = ...  # read-only
    QualifiersOnOutOfBlock: ClassVar[DiagCode] = ...  # read-only
    QueryOnAssociativeNonIntegral: ClassVar[DiagCode] = ...  # read-only
    QueryOnAssociativeWildcard: ClassVar[DiagCode] = ...  # read-only
    QueryOnDynamicType: ClassVar[DiagCode] = ...  # read-only
    RandCInDist: ClassVar[DiagCode] = ...  # read-only
    RandCInSoft: ClassVar[DiagCode] = ...  # read-only
    RandCInSolveBefore: ClassVar[DiagCode] = ...  # read-only
    RandCInUnique: ClassVar[DiagCode] = ...  # read-only
    RandJoinNotEnough: ClassVar[DiagCode] = ...  # read-only
    RandJoinNotNumeric: ClassVar[DiagCode] = ...  # read-only
    RandJoinProdItem: ClassVar[DiagCode] = ...  # read-only
    RandNeededInDist: ClassVar[DiagCode] = ...  # read-only
    RandOnPackedMember: ClassVar[DiagCode] = ...  # read-only
    RandOnUnionMember: ClassVar[DiagCode] = ...  # read-only
    RangeOOB: ClassVar[DiagCode] = ...  # read-only
    RangeSelectAssociative: ClassVar[DiagCode] = ...  # read-only
    RangeWidthOOB: ClassVar[DiagCode] = ...  # read-only
    RangeWidthOverflow: ClassVar[DiagCode] = ...  # read-only
    RawProtectEOF: ClassVar[DiagCode] = ...  # read-only
    RealLiteralOverflow: ClassVar[DiagCode] = ...  # read-only
    RealLiteralUnderflow: ClassVar[DiagCode] = ...  # read-only
    RecursiveDefinition: ClassVar[DiagCode] = ...  # read-only
    RecursiveLet: ClassVar[DiagCode] = ...  # read-only
    RecursiveMacro: ClassVar[DiagCode] = ...  # read-only
    RecursivePropArgExpr: ClassVar[DiagCode] = ...  # read-only
    RecursivePropDisableIff: ClassVar[DiagCode] = ...  # read-only
    RecursivePropNegation: ClassVar[DiagCode] = ...  # read-only
    RecursivePropTimeAdvance: ClassVar[DiagCode] = ...  # read-only
    RecursiveSequence: ClassVar[DiagCode] = ...  # read-only
    RedefiningMacro: ClassVar[DiagCode] = ...  # read-only
    Redefinition: ClassVar[DiagCode] = ...  # read-only
    RedefinitionDifferentType: ClassVar[DiagCode] = ...  # read-only
    RefArgAutomaticFunc: ClassVar[DiagCode] = ...  # read-only
    RefPortMustBeVariable: ClassVar[DiagCode] = ...  # read-only
    RefPortUnconnected: ClassVar[DiagCode] = ...  # read-only
    RefPortUnnamedUnconnected: ClassVar[DiagCode] = ...  # read-only
    RefTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    RegAfterNettype: ClassVar[DiagCode] = ...  # read-only
    RepeatControlNotEvent: ClassVar[DiagCode] = ...  # read-only
    RepeatNotNumeric: ClassVar[DiagCode] = ...  # read-only
    ReplicationZeroOutsideConcat: ClassVar[DiagCode] = ...  # read-only
    RestrictStmtNoFail: ClassVar[DiagCode] = ...  # read-only
    ReturnInParallel: ClassVar[DiagCode] = ...  # read-only
    ReturnNotInSubroutine: ClassVar[DiagCode] = ...  # read-only
    ReversedOpenRange: ClassVar[DiagCode] = ...  # read-only
    SampledValueLocalVar: ClassVar[DiagCode] = ...  # read-only
    SampledValueMatched: ClassVar[DiagCode] = ...  # read-only
    ScopeIncompleteTypedef: ClassVar[DiagCode] = ...  # read-only
    ScopeIndexOutOfRange: ClassVar[DiagCode] = ...  # read-only
    ScopeNotIndexable: ClassVar[DiagCode] = ...  # read-only
    ScopedClassCopy: ClassVar[DiagCode] = ...  # read-only
    SelectEndianDynamic: ClassVar[DiagCode] = ...  # read-only
    SelectEndianMismatch: ClassVar[DiagCode] = ...  # read-only
    SelectOfVectoredNet: ClassVar[DiagCode] = ...  # read-only
    SeqInstanceRepetition: ClassVar[DiagCode] = ...  # read-only
    SeqMethodInputLocalVar: ClassVar[DiagCode] = ...  # read-only
    SeqPropAdmitEmpty: ClassVar[DiagCode] = ...  # read-only
    SeqRangeMinMax: ClassVar[DiagCode] = ...  # read-only
    SequenceMethodLocalVar: ClassVar[DiagCode] = ...  # read-only
    SignedIntegerOverflow: ClassVar[DiagCode] = ...  # read-only
    SignednessNoEffect: ClassVar[DiagCode] = ...  # read-only
    SingleBitVectored: ClassVar[DiagCode] = ...  # read-only
    SolveBeforeDisallowed: ClassVar[DiagCode] = ...  # read-only
    SpecparamInConstant: ClassVar[DiagCode] = ...  # read-only
    SplitBlockCommentInDirective: ClassVar[DiagCode] = ...  # read-only
    StatementNotInLoop: ClassVar[DiagCode] = ...  # read-only
    StaticAssert: ClassVar[DiagCode] = ...  # read-only
    StaticConstNoInitializer: ClassVar[DiagCode] = ...  # read-only
    StaticInitializerMustBeExplicit: ClassVar[DiagCode] = ...  # read-only
    SubroutineMatchAutoRefArg: ClassVar[DiagCode] = ...  # read-only
    SubroutineMatchOutArg: ClassVar[DiagCode] = ...  # read-only
    SubroutinePrototypeScoped: ClassVar[DiagCode] = ...  # read-only
    SuperNoBase: ClassVar[DiagCode] = ...  # read-only
    SuperOutsideClass: ClassVar[DiagCode] = ...  # read-only
    SysFuncHierarchicalNotAllowed: ClassVar[DiagCode] = ...  # read-only
    SysFuncNotConst: ClassVar[DiagCode] = ...  # read-only
    TaggedStruct: ClassVar[DiagCode] = ...  # read-only
    TaggedUnionMissingInit: ClassVar[DiagCode] = ...  # read-only
    TaggedUnionTarget: ClassVar[DiagCode] = ...  # read-only
    TaskConstructor: ClassVar[DiagCode] = ...  # read-only
    TaskFromFinal: ClassVar[DiagCode] = ...  # read-only
    TaskFromFunction: ClassVar[DiagCode] = ...  # read-only
    TaskInConstraint: ClassVar[DiagCode] = ...  # read-only
    TaskReturnType: ClassVar[DiagCode] = ...  # read-only
    ThroughoutLhsInvalid: ClassVar[DiagCode] = ...  # read-only
    TimeScaleFirstInScope: ClassVar[DiagCode] = ...  # read-only
    TimingControlNotAllowed: ClassVar[DiagCode] = ...  # read-only
    TimingInFuncNotAllowed: ClassVar[DiagCode] = ...  # read-only
    TooFewArguments: ClassVar[DiagCode] = ...  # read-only
    TooManyActualMacroArgs: ClassVar[DiagCode] = ...  # read-only
    TooManyArguments: ClassVar[DiagCode] = ...  # read-only
    TooManyErrors: ClassVar[DiagCode] = ...  # read-only
    TooManyForeachVars: ClassVar[DiagCode] = ...  # read-only
    TooManyLexerErrors: ClassVar[DiagCode] = ...  # read-only
    TooManyParamAssignments: ClassVar[DiagCode] = ...  # read-only
    TooManyPortConnections: ClassVar[DiagCode] = ...  # read-only
    TopModuleIfacePort: ClassVar[DiagCode] = ...  # read-only
    TopModuleRefPort: ClassVar[DiagCode] = ...  # read-only
    TopModuleUnnamedRefPort: ClassVar[DiagCode] = ...  # read-only
    TypeHierarchical: ClassVar[DiagCode] = ...  # read-only
    TypeRefDeclVar: ClassVar[DiagCode] = ...  # read-only
    TypeRefHierarchical: ClassVar[DiagCode] = ...  # read-only
    TypoIdentifier: ClassVar[DiagCode] = ...  # read-only
    UTF8Char: ClassVar[DiagCode] = ...  # read-only
    UnbalancedMacroArgDims: ClassVar[DiagCode] = ...  # read-only
    UnboundedNotAllowed: ClassVar[DiagCode] = ...  # read-only
    UnconnectedArg: ClassVar[DiagCode] = ...  # read-only
    UnconnectedNamedPort: ClassVar[DiagCode] = ...  # read-only
    UnconnectedUnnamedPort: ClassVar[DiagCode] = ...  # read-only
    UndeclaredIdentifier: ClassVar[DiagCode] = ...  # read-only
    UndefineBuiltinDirective: ClassVar[DiagCode] = ...  # read-only
    UnexpectedClockingExpr: ClassVar[DiagCode] = ...  # read-only
    UnexpectedConditionalDirective: ClassVar[DiagCode] = ...  # read-only
    UnexpectedConstraintBlock: ClassVar[DiagCode] = ...  # read-only
    UnexpectedLetPortKeyword: ClassVar[DiagCode] = ...  # read-only
    UnexpectedNameToken: ClassVar[DiagCode] = ...  # read-only
    UnexpectedPortDecl: ClassVar[DiagCode] = ...  # read-only
    UnexpectedQualifiers: ClassVar[DiagCode] = ...  # read-only
    UnexpectedSelection: ClassVar[DiagCode] = ...  # read-only
    UnexpectedWithClause: ClassVar[DiagCode] = ...  # read-only
    UnicodeBOM: ClassVar[DiagCode] = ...  # read-only
    UnknownClassMember: ClassVar[DiagCode] = ...  # read-only
    UnknownClassOrPackage: ClassVar[DiagCode] = ...  # read-only
    UnknownConstraintLiteral: ClassVar[DiagCode] = ...  # read-only
    UnknownCovergroupMember: ClassVar[DiagCode] = ...  # read-only
    UnknownDiagPragmaArg: ClassVar[DiagCode] = ...  # read-only
    UnknownDirective: ClassVar[DiagCode] = ...  # read-only
    UnknownEscapeCode: ClassVar[DiagCode] = ...  # read-only
    UnknownFormatSpecifier: ClassVar[DiagCode] = ...  # read-only
    UnknownInterface: ClassVar[DiagCode] = ...  # read-only
    UnknownMember: ClassVar[DiagCode] = ...  # read-only
    UnknownModule: ClassVar[DiagCode] = ...  # read-only
    UnknownPackage: ClassVar[DiagCode] = ...  # read-only
    UnknownPackageMember: ClassVar[DiagCode] = ...  # read-only
    UnknownPragma: ClassVar[DiagCode] = ...  # read-only
    UnknownPrimitive: ClassVar[DiagCode] = ...  # read-only
    UnknownProtectEncoding: ClassVar[DiagCode] = ...  # read-only
    UnknownProtectKeyword: ClassVar[DiagCode] = ...  # read-only
    UnknownProtectOption: ClassVar[DiagCode] = ...  # read-only
    UnknownSystemMethod: ClassVar[DiagCode] = ...  # read-only
    UnknownSystemName: ClassVar[DiagCode] = ...  # read-only
    UnknownWarningOption: ClassVar[DiagCode] = ...  # read-only
    UnpackedArrayParamType: ClassVar[DiagCode] = ...  # read-only
    UnpackedConcatAssociative: ClassVar[DiagCode] = ...  # read-only
    UnpackedConcatSize: ClassVar[DiagCode] = ...  # read-only
    UnpackedSigned: ClassVar[DiagCode] = ...  # read-only
    UnrecognizedKeywordVersion: ClassVar[DiagCode] = ...  # read-only
    UnresolvedForwardTypedef: ClassVar[DiagCode] = ...  # read-only
    UnsizedInConcat: ClassVar[DiagCode] = ...  # read-only
    UnterminatedBlockComment: ClassVar[DiagCode] = ...  # read-only
    UnusedDefinition: ClassVar[DiagCode] = ...  # read-only
    UnusedPortDecl: ClassVar[DiagCode] = ...  # read-only
    UnusedResult: ClassVar[DiagCode] = ...  # read-only
    UsedBeforeDeclared: ClassVar[DiagCode] = ...  # read-only
    UserDefPartialDriver: ClassVar[DiagCode] = ...  # read-only
    UserDefPortMixedConcat: ClassVar[DiagCode] = ...  # read-only
    UserDefPortTwoSided: ClassVar[DiagCode] = ...  # read-only
    ValueExceedsMaxBitWidth: ClassVar[DiagCode] = ...  # read-only
    ValueMustBeIntegral: ClassVar[DiagCode] = ...  # read-only
    ValueMustBePositive: ClassVar[DiagCode] = ...  # read-only
    ValueMustNotBeUnknown: ClassVar[DiagCode] = ...  # read-only
    ValueOutOfRange: ClassVar[DiagCode] = ...  # read-only
    VarDeclWithDelay: ClassVar[DiagCode] = ...  # read-only
    VarWithInterfacePort: ClassVar[DiagCode] = ...  # read-only
    VectorLiteralOverflow: ClassVar[DiagCode] = ...  # read-only
    VirtualArgCountMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualArgDirectionMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualArgNameMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualArgNoDerivedDefault: ClassVar[DiagCode] = ...  # read-only
    VirtualArgNoParentDefault: ClassVar[DiagCode] = ...  # read-only
    VirtualArgTypeMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualInterfaceUnionMember: ClassVar[DiagCode] = ...  # read-only
    VirtualKindMismatch: ClassVar[DiagCode] = ...  # read-only
    VirtualReturnMismatch: ClassVar[DiagCode] = ...  # read-only
    VoidCastFuncCall: ClassVar[DiagCode] = ...  # read-only
    VoidNotAllowed: ClassVar[DiagCode] = ...  # read-only
    WarnNotYetSupported: ClassVar[DiagCode] = ...  # read-only
    WarningTask: ClassVar[DiagCode] = ...  # read-only
    WidthExpand: ClassVar[DiagCode] = ...  # read-only
    WidthTruncate: ClassVar[DiagCode] = ...  # read-only
    WireDataType: ClassVar[DiagCode] = ...  # read-only
    WithClauseNotAllowed: ClassVar[DiagCode] = ...  # read-only
    WriteToInputClockVar: ClassVar[DiagCode] = ...  # read-only
    WrongNumberAssignmentPatterns: ClassVar[DiagCode] = ...  # read-only
    def __init__(self, *args, **kwargs) -> None: ...

class DimensionKind:
    __members__: ClassVar[dict] = ...  # read-only
    AbbreviatedRange: ClassVar[DimensionKind] = ...
    Associative: ClassVar[DimensionKind] = ...
    Dynamic: ClassVar[DimensionKind] = ...
    Queue: ClassVar[DimensionKind] = ...
    Range: ClassVar[DimensionKind] = ...
    Unknown: ClassVar[DimensionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DimensionSpecifierSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class DirectiveSyntax(SyntaxNode):
    directive: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableConstraintSyntax(ConstraintItemSyntax):
    disable: Token
    name: NameSyntax
    semi: Token
    soft: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableForkStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class DisableForkStatementSyntax(StatementSyntax):
    disable: Token
    fork: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableIffAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def condition(self) -> Expression: ...
    @property
    def expr(self) -> AssertionExpr: ...

class DisableIffSyntax(SyntaxNode):
    closeParen: Token
    disable: Token
    expr: ExpressionSyntax
    iff: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DisableSoftConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def target(self) -> Expression: ...

class DisableStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isHierarchical(self) -> bool: ...
    @property
    def target(self) -> Any: ...

class DisableStatementSyntax(StatementSyntax):
    disable: Token
    name: NameSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DistConstraintListSyntax(SyntaxNode):
    closeBrace: Token
    dist: Token
    items: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DistExpression(Expression):
    class DistItem:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def value(self) -> Expression: ...
        @property
        def weight(self) -> Optional[DistExpression.DistWeight]: ...

    class DistWeight:
        class Kind:
            __members__: ClassVar[dict] = ...  # read-only
            PerRange: ClassVar[DistExpression.DistWeight.Kind] = ...
            PerValue: ClassVar[DistExpression.DistWeight.Kind] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        PerRange: ClassVar[DistExpression.DistWeight.Kind] = ...
        PerValue: ClassVar[DistExpression.DistWeight.Kind] = ...
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def kind(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def items(self) -> Any: ...
    @property
    def left(self) -> Expression: ...

class DistItemSyntax(SyntaxNode):
    range: ExpressionSyntax
    weight: DistWeightSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class DistWeightSyntax(SyntaxNode):
    expr: ExpressionSyntax
    op: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DividerClauseSyntax(SyntaxNode):
    divide: Token
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DoWhileLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def cond(self) -> Expression: ...

class DoWhileStatementSyntax(StatementSyntax):
    closeParen: Token
    doKeyword: Token
    expr: ExpressionSyntax
    openParen: Token
    semi: Token
    statement: StatementSyntax
    whileKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DotMemberClauseSyntax(SyntaxNode):
    dot: Token
    member: Token
    def __init__(self, *args, **kwargs) -> None: ...

class DriveStrengthSyntax(NetStrengthSyntax):
    closeParen: Token
    comma: Token
    openParen: Token
    strength0: Token
    strength1: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Driver:
    def __init__(self) -> None: ...
    def addStandardArgs(self) -> None: ...
    def createCompilation(self) -> Compilation: ...
    def createOptionBag(self, *args, **kwargs) -> Any: ...
    def parseAllSources(self) -> bool: ...
    def parseCommandLine(self, arg0: str) -> bool: ...
    def processCommandFile(self, arg0: str, arg1: bool) -> bool: ...
    def processOptions(self) -> bool: ...
    def readSource(self, *args, **kwargs) -> Any: ...
    def reportCompilation(self, arg0: Compilation, arg1: bool) -> bool: ...
    def reportMacros(self) -> None: ...
    def reportParseDiags(self) -> bool: ...
    def runPreprocessor(self, arg0: bool, arg1: bool) -> bool: ...
    @property
    def buffers(self) -> Any: ...
    @property
    def diagClient(self) -> Any: ...
    @property
    def diagEngine(self) -> Any: ...
    @property
    def sourceManager(self) -> Any: ...
    @property
    def syntaxTrees(self) -> Any: ...

class DriverKind:
    __members__: ClassVar[dict] = ...  # read-only
    Continuous: ClassVar[DriverKind] = ...
    Other: ClassVar[DriverKind] = ...
    Procedural: ClassVar[DriverKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class DynamicArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...

class EdgeControlSpecifierSyntax(SyntaxNode):
    closeBracket: Token
    descriptors: Any
    openBracket: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EdgeDescriptorSyntax(SyntaxNode):
    t1: Token
    t2: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EdgeKind:
    __members__: ClassVar[dict] = ...  # read-only
    BothEdges: ClassVar[EdgeKind] = ...
    NegEdge: ClassVar[EdgeKind] = ...
    None: ClassVar[EdgeKind] = ...
    PosEdge: ClassVar[EdgeKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EdgeSensitivePathSuffixSyntax(PathSuffixSyntax):
    closeParen: Token
    colon: Token
    expr: ExpressionSyntax
    openParen: Token
    outputs: Any
    polarityOperator: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElabSystemTaskKind:
    __members__: ClassVar[dict] = ...  # read-only
    Error: ClassVar[ElabSystemTaskKind] = ...
    Fatal: ClassVar[ElabSystemTaskKind] = ...
    Info: ClassVar[ElabSystemTaskKind] = ...
    StaticAssert: ClassVar[ElabSystemTaskKind] = ...
    Warning: ClassVar[ElabSystemTaskKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ElabSystemTaskSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assertCondition(self) -> Expression: ...
    @property
    def message(self) -> str: ...
    @property
    def taskKind(self) -> ElabSystemTaskKind: ...

class ElabSystemTaskSyntax(MemberSyntax):
    arguments: ArgumentListSyntax
    name: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElementSelectExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def selector(self) -> Expression: ...
    @property
    def value(self) -> Expression: ...

class ElementSelectExpressionSyntax(ExpressionSyntax):
    left: ExpressionSyntax
    select: ElementSelectSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ElementSelectSyntax(SyntaxNode):
    closeBracket: Token
    openBracket: Token
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ElseClauseSyntax(SyntaxNode):
    clause: SyntaxNode
    elseKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElseConstraintClauseSyntax(SyntaxNode):
    constraints: ConstraintItemSyntax
    elseKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ElsePropertyClauseSyntax(SyntaxNode):
    elseKeyword: Token
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyArgumentExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyArgumentSyntax(ArgumentSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyIdentifierNameSyntax(NameSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyMemberSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyMemberSyntax(MemberSyntax):
    qualifiers: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyNonAnsiPortSyntax(NonAnsiPortSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyPortConnectionSyntax(PortConnectionSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyQueueExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyStatementSyntax(StatementSyntax):
    semicolon: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EmptyTimingCheckArgSyntax(TimingCheckArgSyntax):
    placeholder: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EnumType(IntegralType, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def baseType(self) -> Type: ...
    @property
    def systemId(self) -> int: ...

class EnumTypeSyntax(DataTypeSyntax):
    baseType: DataTypeSyntax
    closeBrace: Token
    dimensions: Any
    keyword: Token
    members: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EnumValueSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> ConstantValue: ...

class EqualsAssertionArgClauseSyntax(SyntaxNode):
    equals: Token
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EqualsTypeClauseSyntax(SyntaxNode):
    equals: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EqualsValueClauseSyntax(SyntaxNode):
    equals: Token
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ErrorType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class EvalContext:
    class Frame:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def callLocation(self) -> Any: ...
        @property
        def lookupLocation(self) -> Any: ...
        @property
        def subroutine(self) -> Any: ...
        @property
        def temporaries(self) -> Any: ...
    queueTarget: Any
    def __init__(self, arg0, arg1: EvalFlags) -> None: ...
    def createLocal(self, *args, **kwargs) -> Any: ...
    def deleteLocal(self, arg0) -> None: ...
    def dumpStack(self) -> str: ...
    def findLocal(self, *args, **kwargs) -> Any: ...
    def popFrame(self) -> None: ...
    def popLValue(self) -> None: ...
    def pushEmptyFrame(self) -> None: ...
    def pushFrame(self, arg0, arg1, arg2) -> bool: ...
    def pushLValue(self, arg0) -> None: ...
    def setDisableTarget(self, arg0, arg1) -> None: ...
    def step(self, arg0) -> bool: ...
    @property
    def cacheResults(self) -> bool: ...
    @property
    def diagnostics(self) -> Any: ...
    @property
    def disableRange(self) -> Any: ...
    @property
    def disableTarget(self) -> Any: ...
    @property
    def flags(self) -> EvalFlags: ...
    @property
    def inFunction(self) -> bool: ...
    @property
    def topFrame(self) -> Any: ...
    @property
    def topLValue(self) -> Any: ...

class EvalFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowUnboundedPlaceholder: ClassVar[EvalFlags] = ...
    CacheResults: ClassVar[EvalFlags] = ...
    CovergroupExpr: ClassVar[EvalFlags] = ...
    IsScript: ClassVar[EvalFlags] = ...
    None: ClassVar[EvalFlags] = ...
    SpecparamsAllowed: ClassVar[EvalFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class EvaluatedDimension:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def associativeType(self) -> Any: ...
    @property
    def isRange(self) -> bool: ...
    @property
    def kind(self) -> DimensionKind: ...
    @property
    def queueMaxSize(self) -> int: ...
    @property
    def range(self) -> Any: ...

class EventControlSyntax(TimingControlSyntax):
    at: Token
    eventName: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EventControlWithExpressionSyntax(TimingControlSyntax):
    at: Token
    expr: EventExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class EventExpressionSyntax(SequenceExprSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class EventListControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def events(self) -> span[TimingControl]: ...

class EventTriggerStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isNonBlocking(self) -> bool: ...
    @property
    def target(self) -> Expression: ...
    @property
    def timing(self) -> Any: ...

class EventTriggerStatementSyntax(StatementSyntax):
    name: NameSyntax
    semi: Token
    timing: TimingControlSyntax
    trigger: Token
    def __init__(self, *args, **kwargs) -> None: ...

class EventType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class ExplicitAnsiPortSyntax(MemberSyntax):
    closeParen: Token
    direction: Token
    dot: Token
    expr: ExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExplicitImportSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def importName(self) -> str: ...
    @property
    def importedSymbol(self) -> Symbol: ...
    @property
    def isFromExport(self) -> bool: ...
    @property
    def package(self) -> PackageSymbol: ...
    @property
    def packageName(self) -> str: ...

class ExplicitNonAnsiPortSyntax(NonAnsiPortSyntax):
    closeParen: Token
    dot: Token
    expr: PortExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Expression:
    def __init__(self, *args, **kwargs) -> None: ...
    def canConnectToRefArg(self, arg0: bool, arg1: bool) -> bool: ...
    def eval(self, *args, **kwargs) -> Any: ...
    def evalLValue(self, arg0: EvalContext) -> LValue: ...
    def getSymbolReference(self, *args, **kwargs) -> Any: ...
    def isImplicitlyAssignableTo(self, arg0, arg1) -> bool: ...
    @property
    def bad(self) -> bool: ...
    @property
    def constant(self) -> Any: ...
    @property
    def effectiveWidth(self) -> Optional[int]: ...
    @property
    def hasHierarchicalReference(self) -> bool: ...
    @property
    def isImplicitString(self) -> bool: ...
    @property
    def isUnsizedInteger(self) -> bool: ...
    @property
    def kind(self) -> ExpressionKind: ...
    @property
    def sourceRange(self) -> Any: ...
    @property
    def syntax(self) -> Any: ...
    @property
    def type(self) -> Any: ...

class ExpressionConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def isSoft(self) -> bool: ...

class ExpressionConstraintSyntax(ConstraintItemSyntax):
    expr: ExpressionSyntax
    semi: Token
    soft: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionKind:
    __members__: ClassVar[dict] = ...  # read-only
    AssertionInstance: ClassVar[ExpressionKind] = ...
    Assignment: ClassVar[ExpressionKind] = ...
    BinaryOp: ClassVar[ExpressionKind] = ...
    Call: ClassVar[ExpressionKind] = ...
    ClockingEvent: ClassVar[ExpressionKind] = ...
    Concatenation: ClassVar[ExpressionKind] = ...
    ConditionalOp: ClassVar[ExpressionKind] = ...
    Conversion: ClassVar[ExpressionKind] = ...
    CopyClass: ClassVar[ExpressionKind] = ...
    DataType: ClassVar[ExpressionKind] = ...
    Dist: ClassVar[ExpressionKind] = ...
    ElementSelect: ClassVar[ExpressionKind] = ...
    EmptyArgument: ClassVar[ExpressionKind] = ...
    HierarchicalReference: ClassVar[ExpressionKind] = ...
    HierarchicalValue: ClassVar[ExpressionKind] = ...
    Inside: ClassVar[ExpressionKind] = ...
    IntegerLiteral: ClassVar[ExpressionKind] = ...
    Invalid: ClassVar[ExpressionKind] = ...
    LValueReference: ClassVar[ExpressionKind] = ...
    MemberAccess: ClassVar[ExpressionKind] = ...
    MinTypMax: ClassVar[ExpressionKind] = ...
    NamedValue: ClassVar[ExpressionKind] = ...
    NewArray: ClassVar[ExpressionKind] = ...
    NewClass: ClassVar[ExpressionKind] = ...
    NewCovergroup: ClassVar[ExpressionKind] = ...
    NullLiteral: ClassVar[ExpressionKind] = ...
    OpenRange: ClassVar[ExpressionKind] = ...
    RangeSelect: ClassVar[ExpressionKind] = ...
    RealLiteral: ClassVar[ExpressionKind] = ...
    ReplicatedAssignmentPattern: ClassVar[ExpressionKind] = ...
    Replication: ClassVar[ExpressionKind] = ...
    SimpleAssignmentPattern: ClassVar[ExpressionKind] = ...
    Streaming: ClassVar[ExpressionKind] = ...
    StringLiteral: ClassVar[ExpressionKind] = ...
    StructuredAssignmentPattern: ClassVar[ExpressionKind] = ...
    TaggedUnion: ClassVar[ExpressionKind] = ...
    TimeLiteral: ClassVar[ExpressionKind] = ...
    TypeReference: ClassVar[ExpressionKind] = ...
    UnaryOp: ClassVar[ExpressionKind] = ...
    UnbasedUnsizedIntegerLiteral: ClassVar[ExpressionKind] = ...
    UnboundedLiteral: ClassVar[ExpressionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ExpressionOrDistSyntax(ExpressionSyntax):
    distribution: DistConstraintListSyntax
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionPatternSyntax(PatternSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class ExpressionStatementSyntax(StatementSyntax):
    expr: ExpressionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ExpressionTimingCheckArgSyntax(TimingCheckArgSyntax):
    condition: TimingCheckConditionSyntax
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExtendsClauseSyntax(SyntaxNode):
    arguments: ArgumentListSyntax
    baseName: NameSyntax
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExternInterfaceMethodSyntax(MemberSyntax):
    externKeyword: Token
    forkJoin: Token
    prototype: FunctionPrototypeSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ExternModuleDeclSyntax(MemberSyntax):
    actualAttributes: Any
    externKeyword: Token
    header: ModuleHeaderSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ExternUdpDeclSyntax(MemberSyntax):
    actualAttributes: Any
    externKeyword: Token
    name: Token
    portList: UdpPortListSyntax
    primitive: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FieldSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def offset(self) -> int: ...
    @property
    def randMode(self) -> RandMode: ...

class FirstMatchAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def matchItems(self) -> span[Expression]: ...
    @property
    def seq(self) -> AssertionExpr: ...

class FirstMatchSequenceExprSyntax(SequenceExprSyntax):
    closeParen: Token
    expr: SequenceExprSyntax
    first_match: Token
    matchList: SequenceMatchListSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FixedSizeUnpackedArrayType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def range(self) -> ConstantRange: ...

class FloatingType(Type):
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Real: ClassVar[FloatingType.Kind] = ...
        RealTime: ClassVar[FloatingType.Kind] = ...
        ShortReal: ClassVar[FloatingType.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Real: ClassVar[FloatingType.Kind] = ...
    RealTime: ClassVar[FloatingType.Kind] = ...
    ShortReal: ClassVar[FloatingType.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def floatKind(self) -> Any: ...

class ForLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def initializers(self) -> span[Expression]: ...
    @property
    def loopVars(self) -> Any: ...
    @property
    def steps(self) -> span[Expression]: ...
    @property
    def stopExpr(self) -> Expression: ...

class ForLoopStatementSyntax(StatementSyntax):
    closeParen: Token
    forKeyword: Token
    initializers: Any
    openParen: Token
    semi1: Token
    semi2: Token
    statement: StatementSyntax
    steps: Any
    stopExpr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ForVariableDeclarationSyntax(SyntaxNode):
    declarator: DeclaratorSyntax
    type: DataTypeSyntax
    varKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForeachConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayRef(self) -> Expression: ...
    @property
    def body(self) -> Constraint: ...
    @property
    def loopDims(self) -> span[ForeachLoopStatement.LoopDim]: ...

class ForeachLoopListSyntax(SyntaxNode):
    arrayName: NameSyntax
    closeBracket: Token
    closeParen: Token
    loopVariables: Any
    openBracket: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForeachLoopStatement(Statement):
    class LoopDim:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def loopVar(self) -> Any: ...
        @property
        def range(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayRef(self) -> Expression: ...
    @property
    def body(self) -> Statement: ...
    @property
    def loopDims(self) -> Any: ...

class ForeachLoopStatementSyntax(StatementSyntax):
    keyword: Token
    loopList: ForeachLoopListSyntax
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ForeverLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...

class ForeverStatementSyntax(StatementSyntax):
    foreverKeyword: Token
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class FormalArgumentSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...

class ForwardInterfaceClassTypedefDeclarationSyntax(MemberSyntax):
    classKeyword: Token
    interfaceKeyword: Token
    name: Token
    semi: Token
    typedefKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForwardTypedefCategory:
    __members__: ClassVar[dict] = ...  # read-only
    Class: ClassVar[ForwardTypedefCategory] = ...
    Enum: ClassVar[ForwardTypedefCategory] = ...
    InterfaceClass: ClassVar[ForwardTypedefCategory] = ...
    None: ClassVar[ForwardTypedefCategory] = ...
    Struct: ClassVar[ForwardTypedefCategory] = ...
    Union: ClassVar[ForwardTypedefCategory] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ForwardTypedefDeclarationSyntax(MemberSyntax):
    keyword: Token
    name: Token
    semi: Token
    typedefKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ForwardingTypedefSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def category(self) -> ForwardTypedefCategory: ...
    @property
    def nextForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def visibility(self) -> Optional[Visibility]: ...

class FunctionDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    items: Any
    prototype: FunctionPrototypeSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPortListSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    ports: Any
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPortSyntax(SyntaxNode):
    attributes: Any
    constKeyword: Token
    dataType: DataTypeSyntax
    declarator: DeclaratorSyntax
    direction: Token
    varKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionPrototypeSyntax(SyntaxNode):
    keyword: Token
    lifetime: Token
    name: NameSyntax
    portList: FunctionPortListSyntax
    returnType: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class GenerateBlockArraySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def constructIndex(self) -> int: ...
    @property
    def entries(self) -> span[GenerateBlockSymbol]: ...
    @property
    def externalName(self) -> str: ...
    @property
    def valid(self) -> bool: ...

class GenerateBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayIndex(self) -> SVInt: ...
    @property
    def constructIndex(self) -> int: ...
    @property
    def externalName(self) -> str: ...
    @property
    def isInstantiated(self) -> bool: ...

class GenerateBlockSyntax(MemberSyntax):
    begin: Token
    beginName: NamedBlockClauseSyntax
    end: Token
    endName: NamedBlockClauseSyntax
    label: NamedLabelSyntax
    members: Any
    def __init__(self, *args, **kwargs) -> None: ...

class GenerateRegionSyntax(MemberSyntax):
    endgenerate: Token
    keyword: Token
    members: Any
    def __init__(self, *args, **kwargs) -> None: ...

class GenericClassDefSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultSpecialization(self) -> Type: ...
    @property
    def firstForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def invalidSpecialization(self) -> Type: ...
    @property
    def isInterface(self) -> bool: ...

class GenvarDeclarationSyntax(MemberSyntax):
    identifiers: Any
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class GenvarSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...

class HierarchicalInstanceSyntax(SyntaxNode):
    closeParen: Token
    connections: Any
    decl: InstanceNameSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class HierarchicalReferenceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self) -> Any: ...

class HierarchicalValueExpression(ValueExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...

class HierarchyInstantiationSyntax(MemberSyntax):
    instances: Any
    parameters: ParameterValueAssignmentSyntax
    semi: Token
    type: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IdWithExprCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    id: Token
    withClause: WithClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class IdentifierNameSyntax(NameSyntax):
    identifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IdentifierSelectNameSyntax(NameSyntax):
    identifier: Token
    selectors: Any
    def __init__(self, *args, **kwargs) -> None: ...

class IfGenerateSyntax(MemberSyntax):
    block: MemberSyntax
    closeParen: Token
    condition: ExpressionSyntax
    elseClause: ElseClauseSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IfNonePathDeclarationSyntax(MemberSyntax):
    keyword: Token
    path: PathDeclarationSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class IffEventClauseSyntax(SyntaxNode):
    expr: ExpressionSyntax
    iff: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImmediateAssertionMemberSyntax(MemberSyntax):
    statement: ImmediateAssertionStatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImmediateAssertionStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assertionKind(self) -> Any: ...
    @property
    def cond(self) -> Expression: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...
    @property
    def isDeferred(self) -> bool: ...
    @property
    def isFinal(self) -> bool: ...

class ImmediateAssertionStatementSyntax(StatementSyntax):
    action: ActionBlockSyntax
    delay: DeferredAssertionSyntax
    expr: ParenthesizedExpressionSyntax
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImplementsClauseSyntax(SyntaxNode):
    interfaces: Any
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicationConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Constraint: ...
    @property
    def predicate(self) -> Expression: ...

class ImplicationConstraintSyntax(ConstraintItemSyntax):
    arrow: Token
    constraints: ConstraintItemSyntax
    left: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitAnsiPortSyntax(MemberSyntax):
    declarator: DeclaratorSyntax
    header: PortHeaderSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitEventControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitEventControlSyntax(TimingControlSyntax):
    at: Token
    closeParen: Token
    openParen: Token
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitNonAnsiPortSyntax(NonAnsiPortSyntax):
    expr: PortExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ImplicitTypeSyntax(DataTypeSyntax):
    dimensions: Any
    placeholder: Token
    signing: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IncludeDirectiveSyntax(DirectiveSyntax):
    fileName: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InsideExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def rangeList(self) -> span[Expression]: ...

class InsideExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    inside: Token
    ranges: OpenRangeListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class InstanceArraySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayName(self) -> str: ...
    @property
    def elements(self) -> span[Symbol]: ...
    @property
    def range(self) -> ConstantRange: ...

class InstanceBodySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    def findPort(self, arg0: str) -> Symbol: ...
    def hasSameType(self, arg0: InstanceBodySymbol) -> bool: ...
    @property
    def definition(self) -> Definition: ...
    @property
    def isUninstantiated(self) -> bool: ...
    @property
    def parameters(self) -> span[ParameterSymbolBase]: ...
    @property
    def parentInstance(self) -> InstanceSymbol: ...
    @property
    def portList(self) -> span[Symbol]: ...

class InstanceConfigRuleSyntax(ConfigRuleSyntax):
    instance: Token
    instanceNames: Any
    ruleClause: ConfigRuleClauseSyntax
    semi: Token
    topModule: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InstanceNameSyntax(SyntaxNode):
    dimensions: Any
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InstanceSymbol(InstanceSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def getPortConnection(self, arg0: PortSymbol) -> PortConnection: ...
    @overload
    def getPortConnection(self, arg0: MultiPortSymbol) -> PortConnection: ...
    @overload
    def getPortConnection(self, arg0: InterfacePortSymbol) -> PortConnection: ...
    @property
    def body(self) -> Any: ...
    @property
    def definition(self) -> Definition: ...
    @property
    def isInterface(self) -> bool: ...
    @property
    def isModule(self) -> bool: ...

class InstanceSymbolBase(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arrayName(self) -> str: ...
    @property
    def arrayPath(self) -> span[int]: ...

class IntegerLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isDeclaredUnsized(self) -> bool: ...
    @property
    def value(self) -> Any: ...

class IntegerTypeSyntax(DataTypeSyntax):
    dimensions: Any
    keyword: Token
    signing: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IntegerVectorExpressionSyntax(PrimaryExpressionSyntax):
    base: Token
    size: Token
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class IntegralFlags:
    __members__: ClassVar[dict] = ...  # read-only
    FourState: ClassVar[IntegralFlags] = ...
    Reg: ClassVar[IntegralFlags] = ...
    Signed: ClassVar[IntegralFlags] = ...
    TwoState: ClassVar[IntegralFlags] = ...
    Unsigned: ClassVar[IntegralFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IntegralType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    def getBitVectorRange(self) -> ConstantRange: ...
    def isDeclaredReg(self) -> bool: ...

class InterfacePortHeaderSyntax(PortHeaderSyntax):
    modport: DotMemberClauseSyntax
    nameOrKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class InterfacePortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def connection(self) -> Symbol: ...
    @property
    def declaredRange(self) -> Optional[span[ConstantRange]]: ...
    @property
    def interfaceDef(self) -> Definition: ...
    @property
    def isGeneric(self) -> bool: ...
    @property
    def isInvalid(self) -> bool: ...
    @property
    def modport(self) -> str: ...

class IntersectClauseSyntax(SyntaxNode):
    intersect: Token
    ranges: OpenRangeListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class InvalidTimingControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...

class InvocationExpressionSyntax(ExpressionSyntax):
    arguments: ArgumentListSyntax
    attributes: Any
    left: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class IteratorSymbol(TempVarSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class JumpStatementSyntax(StatementSyntax):
    breakOrContinue: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class KeywordNameSyntax(NameSyntax):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class KeywordTypeSyntax(DataTypeSyntax):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LValue:
    def __init__(self) -> None: ...
    def bad(self) -> bool: ...
    def load(self, *args, **kwargs) -> Any: ...
    def resolve(self, *args, **kwargs) -> Any: ...
    def store(self, arg0) -> None: ...

class LValueReferenceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class LetDeclSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class LetDeclarationSyntax(MemberSyntax):
    equals: Token
    expr: ExpressionSyntax
    identifier: Token
    let: Token
    portList: AssertionItemPortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LexerOptions:
    maxErrors: int
    def __init__(self) -> None: ...

class LineDirectiveSyntax(DirectiveSyntax):
    fileName: Token
    level: Token
    lineNumber: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LiteralBase:
    __members__: ClassVar[dict] = ...  # read-only
    Binary: ClassVar[LiteralBase] = ...
    Decimal: ClassVar[LiteralBase] = ...
    Hex: ClassVar[LiteralBase] = ...
    Octal: ClassVar[LiteralBase] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LiteralExpressionSyntax(PrimaryExpressionSyntax):
    literal: Token
    def __init__(self, *args, **kwargs) -> None: ...

class LocalAssertionVarSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class LocalVariableDeclarationSyntax(MemberSyntax):
    declarators: Any
    semi: Token
    type: DataTypeSyntax
    var: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Lookup:
    def __init__(self, *args, **kwargs) -> None: ...
    def ensureAccessible(self, *args, **kwargs) -> Any: ...
    def ensureVisible(self, *args, **kwargs) -> Any: ...
    def findAssertionLocalVar(self, *args, **kwargs) -> Any: ...
    def findClass(self, *args, **kwargs) -> Any: ...
    def findTempVar(self, *args, **kwargs) -> Any: ...
    def getContainingClass(self, *args, **kwargs) -> Any: ...
    def getVisibility(self, *args, **kwargs) -> Any: ...
    def isAccessibleFrom(self, *args, **kwargs) -> Any: ...
    def isVisibleFrom(self, *args, **kwargs) -> Any: ...
    def name(self, *args, **kwargs) -> Any: ...
    def unqualified(self, *args, **kwargs) -> Any: ...
    def unqualifiedAt(self, *args, **kwargs) -> Any: ...
    def withinClassRandomize(self, *args, **kwargs) -> Any: ...

class LookupFlags:
    __members__: ClassVar[dict] = ...  # read-only
    AllowDeclaredAfter: ClassVar[LookupFlags] = ...
    AllowRoot: ClassVar[LookupFlags] = ...
    DisallowWildcardImport: ClassVar[LookupFlags] = ...
    ForceHierarchical: ClassVar[LookupFlags] = ...
    NoParentScope: ClassVar[LookupFlags] = ...
    NoSelectors: ClassVar[LookupFlags] = ...
    NoUndeclaredError: ClassVar[LookupFlags] = ...
    NoUndeclaredErrorIfUninstantiated: ClassVar[LookupFlags] = ...
    None: ClassVar[LookupFlags] = ...
    Type: ClassVar[LookupFlags] = ...
    TypedefTarget: ClassVar[LookupFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LookupLocation:
    max: ClassVar[LookupLocation] = ...  # read-only
    min: ClassVar[LookupLocation] = ...  # read-only
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0, arg1: int) -> None: ...
    def after(self, *args, **kwargs) -> Any: ...
    def before(self, *args, **kwargs) -> Any: ...
    def __eq__(self, arg0: LookupLocation) -> bool: ...
    def __ne__(self, arg0: LookupLocation) -> bool: ...
    @property
    def index(self) -> Any: ...
    @property
    def scope(self) -> Any: ...

class LookupResult:
    class MemberSelector:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def dotLocation(self) -> SourceLocation: ...
        @property
        def name(self) -> str: ...
        @property
        def nameRange(self) -> SourceRange: ...
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def copyFrom(self, arg0: LookupResult) -> None: ...
    def errorIfSelectors(self, arg0: ASTContext) -> None: ...
    def reportDiags(self, arg0: ASTContext) -> None: ...
    @property
    def diagnostics(self) -> Diagnostics: ...
    @property
    def found(self) -> Any: ...
    @property
    def fromForwardTypedef(self) -> bool: ...
    @property
    def fromTypeParam(self) -> bool: ...
    @property
    def hasError(self) -> bool: ...
    @property
    def isHierarchical(self) -> bool: ...
    @property
    def selectors(self) -> Any: ...
    @property
    def suppressUndeclared(self) -> bool: ...
    @property
    def systemSubroutine(self) -> SystemSubroutine: ...
    @property
    def wasImported(self) -> bool: ...

class LoopConstraintSyntax(ConstraintItemSyntax):
    constraints: ConstraintItemSyntax
    foreachKeyword: Token
    loopList: ForeachLoopListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class LoopGenerateSyntax(MemberSyntax):
    block: MemberSyntax
    closeParen: Token
    equals: Token
    genvar: Token
    identifier: Token
    initialExpr: ExpressionSyntax
    iterationExpr: ExpressionSyntax
    keyword: Token
    openParen: Token
    semi1: Token
    semi2: Token
    stopExpr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class LoopStatementSyntax(StatementSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    repeatOrWhile: Token
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class MacroActualArgumentListSyntax(SyntaxNode):
    args: Any
    closeParen: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MacroActualArgumentSyntax(SyntaxNode):
    tokens: Any
    def __init__(self, *args, **kwargs) -> None: ...

class MacroArgumentDefaultSyntax(SyntaxNode):
    equals: Token
    tokens: Any
    def __init__(self, *args, **kwargs) -> None: ...

class MacroFormalArgumentListSyntax(SyntaxNode):
    args: Any
    closeParen: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MacroFormalArgumentSyntax(SyntaxNode):
    defaultValue: MacroArgumentDefaultSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MacroUsageSyntax(DirectiveSyntax):
    args: MacroActualArgumentListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class MatchesClauseSyntax(SyntaxNode):
    matchesKeyword: Token
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class MemberAccessExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def member(self) -> Any: ...
    @property
    def offset(self) -> int: ...
    @property
    def value(self) -> Expression: ...

class MemberAccessExpressionSyntax(ExpressionSyntax):
    dot: Token
    left: ExpressionSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MemberSyntax(SyntaxNode):
    attributes: Any
    def __init__(self, *args, **kwargs) -> None: ...

class MethodFlags:
    __members__: ClassVar[dict] = ...  # read-only
    Constructor: ClassVar[MethodFlags] = ...
    DPIContext: ClassVar[MethodFlags] = ...
    DPIImport: ClassVar[MethodFlags] = ...
    ForkJoin: ClassVar[MethodFlags] = ...
    InterfaceExtern: ClassVar[MethodFlags] = ...
    ModportExport: ClassVar[MethodFlags] = ...
    ModportImport: ClassVar[MethodFlags] = ...
    None: ClassVar[MethodFlags] = ...
    NotConst: ClassVar[MethodFlags] = ...
    Pure: ClassVar[MethodFlags] = ...
    Randomize: ClassVar[MethodFlags] = ...
    Static: ClassVar[MethodFlags] = ...
    Virtual: ClassVar[MethodFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MethodPrototypeSymbol(Symbol, Scope):
    class ExternImpl:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def impl(self) -> SubroutineSymbol: ...
        @property
        def nextImpl(self) -> MethodPrototypeSymbol.ExternImpl: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def firstExternImpl(self) -> Any: ...
    @property
    def flags(self) -> MethodFlags: ...
    @property
    def isVirtual(self) -> bool: ...
    @property
    def override(self) -> Symbol: ...
    @property
    def returnType(self) -> Any: ...
    @property
    def subroutine(self) -> SubroutineSymbol: ...
    @property
    def subroutineKind(self) -> SubroutineKind: ...
    @property
    def visibility(self) -> Visibility: ...

class MinTypMax:
    __members__: ClassVar[dict] = ...  # read-only
    Max: ClassVar[MinTypMax] = ...
    Min: ClassVar[MinTypMax] = ...
    Typ: ClassVar[MinTypMax] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MinTypMaxExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def max(self) -> Expression: ...
    @property
    def min(self) -> Expression: ...
    @property
    def selected(self) -> Expression: ...
    @property
    def typ(self) -> Expression: ...

class MinTypMaxExpressionSyntax(ExpressionSyntax):
    colon1: Token
    colon2: Token
    max: ExpressionSyntax
    min: ExpressionSyntax
    typ: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ModportClockingPortSyntax(MemberSyntax):
    clocking: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportClockingSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def target(self) -> Symbol: ...

class ModportDeclarationSyntax(MemberSyntax):
    items: Any
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportExplicitPortSyntax(ModportPortSyntax):
    closeParen: Token
    dot: Token
    expr: ExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportItemSyntax(SyntaxNode):
    name: Token
    ports: AnsiPortListSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ModportNamedPortSyntax(ModportPortSyntax):
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ModportPortSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def explicitConnection(self) -> Expression: ...
    @property
    def internalSymbol(self) -> Symbol: ...

class ModportPortSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSimplePortListSyntax(MemberSyntax):
    direction: Token
    ports: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSubroutinePortListSyntax(MemberSyntax):
    importExport: Token
    ports: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSubroutinePortSyntax(ModportPortSyntax):
    prototype: FunctionPrototypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ModportSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def hasExports(self) -> bool: ...

class ModuleDeclarationSyntax(MemberSyntax):
    blockName: NamedBlockClauseSyntax
    endmodule: Token
    header: ModuleHeaderSyntax
    members: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ModuleHeaderSyntax(SyntaxNode):
    imports: Any
    lifetime: Token
    moduleKeyword: Token
    name: Token
    parameters: ParameterPortListSyntax
    ports: PortListSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class MultiPortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def isNullPort(self) -> bool: ...
    @property
    def ports(self) -> span[PortSymbol]: ...
    @property
    def type(self) -> Any: ...

class MultipleConcatenationExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    concatenation: ConcatenationExpressionSyntax
    expression: ExpressionSyntax
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NameSyntax(ExpressionSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class NameValuePragmaExpressionSyntax(PragmaExpressionSyntax):
    equals: Token
    name: Token
    value: PragmaExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NamedArgumentSyntax(ArgumentSyntax):
    closeParen: Token
    dot: Token
    expr: PropertyExprSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedBlockClauseSyntax(SyntaxNode):
    colon: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedLabelSyntax(SyntaxNode):
    colon: Token
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedParamAssignmentSyntax(ParamAssignmentSyntax):
    closeParen: Token
    dot: Token
    expr: ExpressionSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedPortConnectionSyntax(PortConnectionSyntax):
    closeParen: Token
    dot: Token
    expr: PropertyExprSyntax
    name: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NamedStructurePatternMemberSyntax(StructurePatternMemberSyntax):
    colon: Token
    name: Token
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NamedTypeSyntax(DataTypeSyntax):
    name: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NamedValueExpression(ValueExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...

class NetAliasSyntax(MemberSyntax):
    keyword: Token
    nets: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NetDeclarationSyntax(MemberSyntax):
    declarators: Any
    delay: TimingControlSyntax
    expansionHint: Token
    netType: Token
    semi: Token
    strength: NetStrengthSyntax
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NetPortHeaderSyntax(PortHeaderSyntax):
    dataType: DataTypeSyntax
    direction: Token
    netType: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NetStrengthSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class NetSymbol(ValueSymbol):
    class ExpansionHint:
        __members__: ClassVar[dict] = ...  # read-only
        None: ClassVar[NetSymbol.ExpansionHint] = ...
        Scalared: ClassVar[NetSymbol.ExpansionHint] = ...
        Vectored: ClassVar[NetSymbol.ExpansionHint] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    None: ClassVar[NetSymbol.ExpansionHint] = ...
    Scalared: ClassVar[NetSymbol.ExpansionHint] = ...
    Vectored: ClassVar[NetSymbol.ExpansionHint] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def expansionHint(self) -> Any: ...
    @property
    def netType(self) -> Any: ...

class NetType(Symbol):
    class NetKind:
        __members__: ClassVar[dict] = ...  # read-only
        Interconnect: ClassVar[NetType.NetKind] = ...
        Supply0: ClassVar[NetType.NetKind] = ...
        Supply1: ClassVar[NetType.NetKind] = ...
        Tri: ClassVar[NetType.NetKind] = ...
        Tri0: ClassVar[NetType.NetKind] = ...
        Tri1: ClassVar[NetType.NetKind] = ...
        TriAnd: ClassVar[NetType.NetKind] = ...
        TriOr: ClassVar[NetType.NetKind] = ...
        TriReg: ClassVar[NetType.NetKind] = ...
        UWire: ClassVar[NetType.NetKind] = ...
        Unknown: ClassVar[NetType.NetKind] = ...
        UserDefined: ClassVar[NetType.NetKind] = ...
        WAnd: ClassVar[NetType.NetKind] = ...
        WOr: ClassVar[NetType.NetKind] = ...
        Wire: ClassVar[NetType.NetKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Interconnect: ClassVar[NetType.NetKind] = ...
    Supply0: ClassVar[NetType.NetKind] = ...
    Supply1: ClassVar[NetType.NetKind] = ...
    Tri: ClassVar[NetType.NetKind] = ...
    Tri0: ClassVar[NetType.NetKind] = ...
    Tri1: ClassVar[NetType.NetKind] = ...
    TriAnd: ClassVar[NetType.NetKind] = ...
    TriOr: ClassVar[NetType.NetKind] = ...
    TriReg: ClassVar[NetType.NetKind] = ...
    UWire: ClassVar[NetType.NetKind] = ...
    Unknown: ClassVar[NetType.NetKind] = ...
    UserDefined: ClassVar[NetType.NetKind] = ...
    WAnd: ClassVar[NetType.NetKind] = ...
    WOr: ClassVar[NetType.NetKind] = ...
    Wire: ClassVar[NetType.NetKind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def getSimulatedNetType(self, *args, **kwargs) -> Any: ...
    @property
    def declaredType(self) -> Any: ...
    @property
    def isBuiltIn(self) -> bool: ...
    @property
    def isError(self) -> bool: ...
    @property
    def netKind(self) -> Any: ...
    @property
    def resolutionFunction(self) -> SubroutineSymbol: ...

class NetTypeDeclarationSyntax(MemberSyntax):
    keyword: Token
    name: Token
    semi: Token
    type: DataTypeSyntax
    withFunction: WithFunctionClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NewArrayExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initExpr(self) -> Expression: ...
    @property
    def sizeExpr(self) -> Expression: ...

class NewArrayExpressionSyntax(ExpressionSyntax):
    closeBracket: Token
    initializer: ParenthesizedExpressionSyntax
    newKeyword: NameSyntax
    openBracket: Token
    sizeExpr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NewClassExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def constructorCall(self) -> Expression: ...
    @property
    def isSuperClass(self) -> bool: ...

class NewClassExpressionSyntax(ExpressionSyntax):
    argList: ArgumentListSyntax
    scopedNew: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class NewCovergroupExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[Expression]: ...

class NonAnsiPortListSyntax(PortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Any
    def __init__(self, *args, **kwargs) -> None: ...

class NonAnsiPortSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class NonAnsiUdpPortListSyntax(UdpPortListSyntax):
    closeParen: Token
    openParen: Token
    ports: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class NonConstantFunction(SimpleSystemSubroutine):
    def __init__(self, name: str, returnType, requiredArgs: int = ..., argTypes = ..., isMethod: bool = ...) -> None: ...

class Null:
    def __init__(self) -> None: ...

class NullLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class NullType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class NumberPragmaExpressionSyntax(PragmaExpressionSyntax):
    base: Token
    size: Token
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class OneStepDelayControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...

class OneStepDelaySyntax(TimingControlSyntax):
    hash: Token
    oneStep: Token
    def __init__(self, *args, **kwargs) -> None: ...

class OpenRangeExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...

class OpenRangeExpressionSyntax(ExpressionSyntax):
    closeBracket: Token
    colon: Token
    left: ExpressionSyntax
    openBracket: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OpenRangeListSyntax(SyntaxNode):
    closeBrace: Token
    openBrace: Token
    valueRanges: Any
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedArgumentSyntax(ArgumentSyntax):
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedParamAssignmentSyntax(ParamAssignmentSyntax):
    expr: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedPortConnectionSyntax(PortConnectionSyntax):
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class OrderedStructurePatternMemberSyntax(StructurePatternMemberSyntax):
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PackageExportAllDeclarationSyntax(MemberSyntax):
    doubleColon: Token
    keyword: Token
    semi: Token
    star1: Token
    star2: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageExportDeclarationSyntax(MemberSyntax):
    items: Any
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageImportDeclarationSyntax(MemberSyntax):
    items: Any
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageImportItemSyntax(SyntaxNode):
    doubleColon: Token
    item: Token
    package: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PackageSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    def findForImport(self, arg0: str) -> Symbol: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...
    @property
    def defaultNetType(self) -> Any: ...
    @property
    def exportDecls(self) -> Any: ...
    @property
    def hasExportAll(self) -> bool: ...
    @property
    def timeScale(self) -> TimeScale: ...

class PackedArrayType(IntegralType):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def range(self) -> ConstantRange: ...

class PackedStructType(IntegralType, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def systemId(self) -> int: ...

class PackedUnionType(IntegralType, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isTagged(self) -> bool: ...
    @property
    def systemId(self) -> int: ...
    @property
    def tagBits(self) -> int: ...

class ParamAssignmentSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterDeclarationBaseSyntax(SyntaxNode):
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterDeclarationStatementSyntax(MemberSyntax):
    parameter: ParameterDeclarationBaseSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterDeclarationSyntax(ParameterDeclarationBaseSyntax):
    declarators: Any
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterPortListSyntax(SyntaxNode):
    closeParen: Token
    declarations: Any
    hash: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParameterSymbol(ValueSymbol, ParameterSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> ConstantValue: ...

class ParameterSymbolBase:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def hasDefault(self) -> bool: ...
    @property
    def isBodyParam(self) -> bool: ...
    @property
    def isLocalParam(self) -> bool: ...
    @property
    def isPortParam(self) -> bool: ...

class ParameterValueAssignmentSyntax(SyntaxNode):
    closeParen: Token
    hash: Token
    openParen: Token
    parameters: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ParenExpressionListSyntax(SyntaxNode):
    closeParen: Token
    expressions: Any
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenPragmaExpressionSyntax(PragmaExpressionSyntax):
    closeParen: Token
    openParen: Token
    values: Any
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    closeParen: Token
    expr: BinsSelectExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedEventExpressionSyntax(EventExpressionSyntax):
    closeParen: Token
    expr: EventExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedExpressionSyntax(PrimaryExpressionSyntax):
    closeParen: Token
    expression: ExpressionSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedPatternSyntax(PatternSyntax):
    closeParen: Token
    openParen: Token
    pattern: PatternSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    expr: PropertyExprSyntax
    matchList: SequenceMatchListSyntax
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ParenthesizedSequenceExprSyntax(SequenceExprSyntax):
    closeParen: Token
    expr: SequenceExprSyntax
    matchList: SequenceMatchListSyntax
    openParen: Token
    repetition: SequenceRepetitionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ParserOptions:
    maxRecursionDepth: int
    def __init__(self) -> None: ...

class PathDeclarationSyntax(MemberSyntax):
    closeParen: Token
    delays: Any
    desc: PathDescriptionSyntax
    equals: Token
    openParen: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PathDescriptionSyntax(SyntaxNode):
    closeParen: Token
    edgeIdentifier: Token
    inputs: Any
    openParen: Token
    pathOperator: Token
    polarityOperator: Token
    suffix: PathSuffixSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PathSuffixSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class Pattern:
    def __init__(self, *args, **kwargs) -> None: ...
    def eval(self, *args, **kwargs) -> Any: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> PatternKind: ...
    @property
    def sourceRange(self) -> Any: ...
    @property
    def syntax(self) -> Any: ...

class PatternCaseItemSyntax(CaseItemSyntax):
    colon: Token
    expr: ExpressionSyntax
    pattern: PatternSyntax
    statement: StatementSyntax
    tripleAnd: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PatternCaseStatement(Statement):
    class ItemGroup:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def filter(self) -> Expression: ...
        @property
        def pattern(self) -> Any: ...
        @property
        def stmt(self) -> Statement: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def check(self) -> CaseStatementCheck: ...
    @property
    def condition(self) -> CaseStatementCondition: ...
    @property
    def defaultCase(self) -> Statement: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def items(self) -> Any: ...

class PatternKind:
    __members__: ClassVar[dict] = ...  # read-only
    Constant: ClassVar[PatternKind] = ...
    Invalid: ClassVar[PatternKind] = ...
    Structure: ClassVar[PatternKind] = ...
    Tagged: ClassVar[PatternKind] = ...
    Variable: ClassVar[PatternKind] = ...
    Wildcard: ClassVar[PatternKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PatternSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PatternVarSymbol(TempVarSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class PortConcatenationSyntax(PortExpressionSyntax):
    closeBrace: Token
    openBrace: Token
    references: Any
    def __init__(self, *args, **kwargs) -> None: ...

class PortConnection:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expression(self) -> Expression: ...
    @property
    def ifaceInstance(self) -> Symbol: ...
    @property
    def parentInstance(self) -> Any: ...
    @property
    def port(self) -> Symbol: ...

class PortConnectionSyntax(SyntaxNode):
    attributes: Any
    def __init__(self, *args, **kwargs) -> None: ...

class PortDeclarationSyntax(MemberSyntax):
    declarators: Any
    header: PortHeaderSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PortExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PortHeaderSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PortListSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PortReferenceSyntax(PortExpressionSyntax):
    name: Token
    select: ElementSelectSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PortSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> ArgumentDirection: ...
    @property
    def externalLoc(self) -> SourceLocation: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def internalExpr(self) -> Expression: ...
    @property
    def internalSymbol(self) -> Symbol: ...
    @property
    def isAnsiPort(self) -> bool: ...
    @property
    def isNetPort(self) -> bool: ...
    @property
    def isNullPort(self) -> bool: ...
    @property
    def type(self) -> Any: ...

class PostfixUnaryExpressionSyntax(ExpressionSyntax):
    attributes: Any
    operand: ExpressionSyntax
    operatorToken: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PragmaDirectiveSyntax(DirectiveSyntax):
    args: Any
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PragmaExpressionSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PredefinedIntegerType(IntegralType):
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Byte: ClassVar[PredefinedIntegerType.Kind] = ...
        Int: ClassVar[PredefinedIntegerType.Kind] = ...
        Integer: ClassVar[PredefinedIntegerType.Kind] = ...
        LongInt: ClassVar[PredefinedIntegerType.Kind] = ...
        ShortInt: ClassVar[PredefinedIntegerType.Kind] = ...
        Time: ClassVar[PredefinedIntegerType.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Byte: ClassVar[PredefinedIntegerType.Kind] = ...
    Int: ClassVar[PredefinedIntegerType.Kind] = ...
    Integer: ClassVar[PredefinedIntegerType.Kind] = ...
    LongInt: ClassVar[PredefinedIntegerType.Kind] = ...
    ShortInt: ClassVar[PredefinedIntegerType.Kind] = ...
    Time: ClassVar[PredefinedIntegerType.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def integerKind(self) -> Any: ...

class PrefixUnaryExpressionSyntax(ExpressionSyntax):
    attributes: Any
    operand: ExpressionSyntax
    operatorToken: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PreprocessorOptions:
    maxIncludeDepth: int
    predefineSource: str
    predefines: List[str]
    undefines: List[str]
    def __init__(self) -> None: ...

class PrimaryBlockEventExpressionSyntax(BlockEventExpressionSyntax):
    keyword: Token
    name: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PrimaryExpressionSyntax(ExpressionSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class PrimitiveInstanceSymbol(InstanceSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def delay(self) -> TimingControl: ...
    @property
    def portConnections(self) -> span[Expression]: ...
    @property
    def primitiveType(self) -> Any: ...

class PrimitiveInstantiationSyntax(MemberSyntax):
    delay: TimingControlSyntax
    instances: Any
    semi: Token
    strength: NetStrengthSyntax
    type: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PrimitivePortDirection:
    __members__: ClassVar[dict] = ...  # read-only
    In: ClassVar[PrimitivePortDirection] = ...
    InOut: ClassVar[PrimitivePortDirection] = ...
    Out: ClassVar[PrimitivePortDirection] = ...
    OutReg: ClassVar[PrimitivePortDirection] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PrimitivePortSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def direction(self) -> PrimitivePortDirection: ...

class PrimitiveSymbol(Symbol, Scope):
    class PrimitiveKind:
        __members__: ClassVar[dict] = ...  # read-only
        Fixed: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        NInput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        NOutput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        UserDefined: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Fixed: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    NInput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    NOutput: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    UserDefined: ClassVar[PrimitiveSymbol.PrimitiveKind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def initVal(self) -> ConstantValue: ...
    @property
    def isSequential(self) -> bool: ...
    @property
    def ports(self) -> span[PrimitivePortSymbol]: ...
    @property
    def primitiveKind(self) -> Any: ...

class ProceduralAssignStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def assignment(self) -> Expression: ...
    @property
    def isForce(self) -> bool: ...

class ProceduralAssignStatementSyntax(StatementSyntax):
    expr: ExpressionSyntax
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ProceduralBlockKind:
    __members__: ClassVar[dict] = ...  # read-only
    Always: ClassVar[ProceduralBlockKind] = ...
    AlwaysComb: ClassVar[ProceduralBlockKind] = ...
    AlwaysFF: ClassVar[ProceduralBlockKind] = ...
    AlwaysLatch: ClassVar[ProceduralBlockKind] = ...
    Final: ClassVar[ProceduralBlockKind] = ...
    Initial: ClassVar[ProceduralBlockKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ProceduralBlockSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def isSingleDriverBlock(self) -> bool: ...
    @property
    def procedureKind(self) -> ProceduralBlockKind: ...

class ProceduralBlockSyntax(MemberSyntax):
    keyword: Token
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ProceduralDeassignStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isRelease(self) -> bool: ...
    @property
    def lvalue(self) -> Expression: ...

class ProceduralDeassignStatementSyntax(StatementSyntax):
    keyword: Token
    semi: Token
    variable: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class ProductionSyntax(SyntaxNode):
    colon: Token
    dataType: DataTypeSyntax
    name: Token
    portList: FunctionPortListSyntax
    rules: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PropertyCaseItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PropertyDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    keyword: Token
    name: Token
    optionalSemi: Token
    portList: AssertionItemPortListSyntax
    propertySpec: PropertySpecSyntax
    semi: Token
    variables: Any
    def __init__(self, *args, **kwargs) -> None: ...

class PropertyExprSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class PropertySpecSyntax(SyntaxNode):
    clocking: TimingControlSyntax
    disable: DisableIffSyntax
    expr: PropertyExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class PropertySymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class PropertyType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class PullStrengthSyntax(NetStrengthSyntax):
    closeParen: Token
    openParen: Token
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class PulseStyleDeclarationSyntax(MemberSyntax):
    inputs: Any
    keyword: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class QueueDimensionSpecifierSyntax(DimensionSpecifierSyntax):
    dollar: Token
    maxSizeClause: ColonExpressionClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class QueueType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elementType(self) -> Type: ...
    @property
    def maxBound(self) -> int: ...

class RandCaseItemSyntax(SyntaxNode):
    colon: Token
    expr: ExpressionSyntax
    statement: StatementSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RandCaseStatement(Statement):
    class Item:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def stmt(self) -> Statement: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def items(self) -> Any: ...

class RandCaseStatementSyntax(StatementSyntax):
    endCase: Token
    items: Any
    randCase: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RandJoinClauseSyntax(SyntaxNode):
    expr: ParenthesizedExpressionSyntax
    join: Token
    rand: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RandMode:
    __members__: ClassVar[dict] = ...  # read-only
    None: ClassVar[RandMode] = ...
    Rand: ClassVar[RandMode] = ...
    RandC: ClassVar[RandMode] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RandSeqProductionSymbol(Symbol, Scope):
    class CaseItem:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expressions(self) -> span[Expression]: ...
        @property
        def item(self) -> RandSeqProductionSymbol.ProdItem: ...

    class CaseProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def defaultItem(self) -> Optional[RandSeqProductionSymbol.ProdItem]: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def items(self) -> span[RandSeqProductionSymbol.CaseItem]: ...

    class CodeBlockProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def block(self) -> StatementBlockSymbol: ...

    class IfElseProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def elseItem(self) -> Optional[RandSeqProductionSymbol.ProdItem]: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def ifItem(self) -> RandSeqProductionSymbol.ProdItem: ...

    class ProdBase:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def kind(self) -> RandSeqProductionSymbol.ProdKind: ...

    class ProdItem(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def args(self) -> span[Expression]: ...
        @property
        def target(self) -> RandSeqProductionSymbol: ...

    class ProdKind:
        __members__: ClassVar[dict] = ...  # read-only
        Case: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        CodeBlock: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        IfElse: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        Item: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        Repeat: ClassVar[RandSeqProductionSymbol.ProdKind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class RepeatProd(RandSeqProductionSymbol.ProdBase):
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def item(self) -> RandSeqProductionSymbol.ProdItem: ...

    class Rule:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def codeBlock(self) -> Optional[RandSeqProductionSymbol.CodeBlockProd]: ...
        @property
        def isRandJoin(self) -> bool: ...
        @property
        def prods(self) -> span[RandSeqProductionSymbol.ProdBase]: ...
        @property
        def randJoinExpr(self) -> Expression: ...
        @property
        def ruleBlock(self) -> StatementBlockSymbol: ...
        @property
        def weightExpr(self) -> Expression: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def returnType(self) -> Any: ...
    @property
    def rules(self) -> Any: ...

class RandSequenceStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def firstProduction(self) -> Any: ...

class RandSequenceStatementSyntax(StatementSyntax):
    closeParen: Token
    endsequence: Token
    firstProduction: Token
    openParen: Token
    productions: Any
    randsequence: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RangeCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    ranges: OpenRangeListSyntax
    withClause: WithClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RangeDimensionSpecifierSyntax(DimensionSpecifierSyntax):
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RangeSelectExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def left(self) -> Expression: ...
    @property
    def right(self) -> Expression: ...
    @property
    def selectionKind(self) -> RangeSelectionKind: ...
    @property
    def value(self) -> Expression: ...

class RangeSelectSyntax(SelectorSyntax):
    left: ExpressionSyntax
    range: Token
    right: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RangeSelectionKind:
    __members__: ClassVar[dict] = ...  # read-only
    IndexedDown: ClassVar[RangeSelectionKind] = ...
    IndexedUp: ClassVar[RangeSelectionKind] = ...
    Simple: ClassVar[RangeSelectionKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RealLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> float: ...

class RepeatLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def count(self) -> Expression: ...

class RepeatedEventControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def event(self) -> TimingControl: ...
    @property
    def expr(self) -> Expression: ...

class RepeatedEventControlSyntax(TimingControlSyntax):
    closeParen: Token
    eventControl: TimingControlSyntax
    expr: ExpressionSyntax
    openParen: Token
    repeat: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ReplicatedAssignmentPatternExpression(AssignmentPatternExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def count(self) -> Expression: ...

class ReplicatedAssignmentPatternSyntax(AssignmentPatternSyntax):
    closeBrace: Token
    countExpr: ExpressionSyntax
    innerCloseBrace: Token
    innerOpenBrace: Token
    items: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ReplicationExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def concat(self) -> Expression: ...
    @property
    def count(self) -> Expression: ...

class ReportedDiagnostic:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expansionLocs(self) -> span[SourceLocation]: ...
    @property
    def formattedMessage(self) -> str: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def originalDiagnostic(self) -> Diagnostic: ...
    @property
    def ranges(self) -> span[SourceRange]: ...
    @property
    def severity(self) -> DiagnosticSeverity: ...
    @property
    def shouldShowIncludeStack(self) -> bool: ...

class ReturnStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...

class ReturnStatementSyntax(StatementSyntax):
    returnKeyword: Token
    returnValue: ExpressionSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RootSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def compilationUnits(self) -> span[CompilationUnitSymbol]: ...
    @property
    def topInstances(self) -> Any: ...

class RsCaseItemSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class RsCaseSyntax(RsProdSyntax):
    closeParen: Token
    endcase: Token
    expr: ExpressionSyntax
    items: Any
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsCodeBlockSyntax(RsProdSyntax):
    closeBrace: Token
    items: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsElseClauseSyntax(SyntaxNode):
    item: RsProdItemSyntax
    keyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsIfElseSyntax(RsProdSyntax):
    closeParen: Token
    condition: ExpressionSyntax
    elseClause: RsElseClauseSyntax
    ifItem: RsProdItemSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsProdItemSyntax(RsProdSyntax):
    argList: ArgumentListSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsProdSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class RsRepeatSyntax(RsProdSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    item: RsProdItemSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class RsRuleSyntax(SyntaxNode):
    prods: Any
    randJoin: RandJoinClauseSyntax
    weightClause: RsWeightClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class RsWeightClauseSyntax(SyntaxNode):
    codeBlock: RsProdSyntax
    colonEqual: Token
    weight: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SVInt:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: logic_t) -> None: ...
    @overload
    def __init__(self, arg0: int, arg1: int, arg2: bool) -> None: ...
    @overload
    def __init__(self, arg0: int, arg1, arg2: bool) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: float) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def ashr(self, arg0: SVInt) -> SVInt: ...
    def concat(self, *args, **kwargs) -> Any: ...
    def conditional(self, *args, **kwargs) -> Any: ...
    def countLeadingOnes(self) -> int: ...
    def countLeadingZeros(self) -> int: ...
    def countOnes(self) -> int: ...
    def countXs(self) -> int: ...
    def countZeros(self) -> int: ...
    def countZs(self) -> int: ...
    def createFillX(self, *args, **kwargs) -> Any: ...
    def createFillZ(self, *args, **kwargs) -> Any: ...
    def extend(self, arg0: int, arg1: bool) -> SVInt: ...
    def flattenUnknowns(self) -> None: ...
    def fromDigits(self, *args, **kwargs) -> Any: ...
    def fromDouble(self, *args, **kwargs) -> Any: ...
    def fromFloat(self, *args, **kwargs) -> Any: ...
    def getActiveBits(self) -> int: ...
    def getMinRepresentedBits(self) -> int: ...
    def isEven(self) -> bool: ...
    def isNegative(self) -> bool: ...
    def isOdd(self) -> bool: ...
    def isSignExtendedFrom(self, arg0: int) -> bool: ...
    def logicalEquiv(self, *args, **kwargs) -> Any: ...
    def logicalImpl(self, *args, **kwargs) -> Any: ...
    def lshr(self, arg0: SVInt) -> SVInt: ...
    def reductionAnd(self) -> logic_t: ...
    def reductionOr(self) -> logic_t: ...
    def reductionXor(self) -> logic_t: ...
    def replicate(self, arg0: SVInt) -> SVInt: ...
    def resize(self, arg0: int) -> SVInt: ...
    def reverse(self) -> SVInt: ...
    def set(self, arg0: int, arg1: int, arg2: SVInt) -> None: ...
    def setAllOnes(self) -> None: ...
    def setAllX(self) -> None: ...
    def setAllZ(self) -> None: ...
    def setAllZeros(self) -> None: ...
    def setSigned(self, arg0: bool) -> None: ...
    def sext(self, arg0: int) -> SVInt: ...
    def shl(self, arg0: SVInt) -> SVInt: ...
    def shrinkToFit(self) -> None: ...
    def signExtendFrom(self, arg0: int) -> None: ...
    def slice(self, arg0: int, arg1: int) -> SVInt: ...
    def toString(self, arg0: LiteralBase, arg1: bool, arg2: int) -> str: ...
    def trunc(self, arg0: int) -> SVInt: ...
    def xnor(self, arg0: SVInt) -> SVInt: ...
    def zext(self, arg0: int) -> SVInt: ...
    @overload
    def __add__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __add__(self, arg0: int) -> SVInt: ...
    @overload
    def __and__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __and__(self, arg0: int) -> SVInt: ...
    def __bool__(self) -> bool: ...
    @overload
    def __eq__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __eq__(self, arg0: int) -> logic_t: ...
    def __float__(self) -> float: ...
    @overload
    def __ge__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __ge__(self, arg0: int) -> logic_t: ...
    def __getitem__(self, arg0: int) -> logic_t: ...
    @overload
    def __gt__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __gt__(self, arg0: int) -> logic_t: ...
    def __hash__(self) -> int: ...
    @overload
    def __iadd__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __iadd__(self, arg0: int) -> SVInt: ...
    @overload
    def __iand__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __iand__(self, arg0: int) -> SVInt: ...
    @overload
    def __imod__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __imod__(self, arg0: int) -> SVInt: ...
    @overload
    def __imul__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __imul__(self, arg0: int) -> SVInt: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> SVInt: ...
    @overload
    def __ior__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __ior__(self, arg0: int) -> SVInt: ...
    @overload
    def __isub__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __isub__(self, arg0: int) -> SVInt: ...
    @overload
    def __itruediv__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __itruediv__(self, arg0: int) -> SVInt: ...
    @overload
    def __ixor__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __ixor__(self, arg0: int) -> SVInt: ...
    @overload
    def __le__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __le__(self, arg0: int) -> logic_t: ...
    @overload
    def __lt__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __lt__(self, arg0: int) -> logic_t: ...
    @overload
    def __mod__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __mod__(self, arg0: int) -> SVInt: ...
    @overload
    def __mul__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __mul__(self, arg0: int) -> SVInt: ...
    @overload
    def __ne__(self, arg0: SVInt) -> logic_t: ...
    @overload
    def __ne__(self, arg0: int) -> logic_t: ...
    def __neg__(self) -> SVInt: ...
    @overload
    def __or__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __or__(self, arg0: int) -> SVInt: ...
    def __pow__(self, arg0: SVInt) -> SVInt: ...
    def __radd__(self, arg0: int) -> SVInt: ...
    def __rand__(self, arg0: int) -> SVInt: ...
    def __rdiv__(self, arg0: int) -> SVInt: ...
    def __rmod__(self, arg0: int) -> SVInt: ...
    def __rmul__(self, arg0: int) -> SVInt: ...
    def __ror__(self, arg0: int) -> SVInt: ...
    def __rsub__(self, arg0: int) -> SVInt: ...
    def __rxor__(self, arg0: int) -> SVInt: ...
    @overload
    def __sub__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __sub__(self, arg0: int) -> SVInt: ...
    @overload
    def __truediv__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __truediv__(self, arg0: int) -> SVInt: ...
    @overload
    def __xor__(self, arg0: SVInt) -> SVInt: ...
    @overload
    def __xor__(self, arg0: int) -> SVInt: ...
    @property
    def bitWidth(self) -> int: ...
    @property
    def hasUnknown(self) -> bool: ...
    @property
    def isSigned(self) -> bool: ...

class ScalarType(IntegralType):
    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Bit: ClassVar[ScalarType.Kind] = ...
        Logic: ClassVar[ScalarType.Kind] = ...
        Reg: ClassVar[ScalarType.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Bit: ClassVar[ScalarType.Kind] = ...
    Logic: ClassVar[ScalarType.Kind] = ...
    Reg: ClassVar[ScalarType.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def scalarKind(self) -> Any: ...

class Scope:
    def __init__(self, *args, **kwargs) -> None: ...
    def find(self, arg0: str) -> Symbol: ...
    def lookupName(self, name: str, location: LookupLocation = ..., flags: LookupFlags = ...) -> Symbol: ...
    def __getitem__(self, arg0: int) -> object: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @property
    def compilation(self) -> Compilation: ...
    @property
    def containingInstance(self) -> Any: ...
    @property
    def defaultNetType(self) -> Any: ...
    @property
    def isProceduralContext(self) -> bool: ...
    @property
    def isUninstantiated(self) -> bool: ...
    @property
    def timeScale(self) -> TimeScale: ...

class ScopedNameSyntax(NameSyntax):
    left: NameSyntax
    right: NameSyntax
    separator: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ScriptSession:
    def __init__(self) -> None: ...
    def eval(self, *args, **kwargs) -> Any: ...
    def evalExpression(self, *args, **kwargs) -> Any: ...
    def evalStatement(self, arg0) -> None: ...
    def getDiagnostics(self, *args, **kwargs) -> Any: ...
    @property
    def compilation(self) -> Compilation: ...

class SelectorSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceConcatExpr(AssertionExpr):
    class Element:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def delay(self) -> SequenceRange: ...
        @property
        def sequence(self) -> AssertionExpr: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def elements(self) -> Any: ...

class SequenceDeclarationSyntax(MemberSyntax):
    end: Token
    endBlockName: NamedBlockClauseSyntax
    keyword: Token
    name: Token
    optionalSemi: Token
    portList: AssertionItemPortListSyntax
    semi: Token
    seqExpr: SequenceExprSyntax
    variables: Any
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceExprSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceMatchListSyntax(SyntaxNode):
    comma: Token
    items: Any
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceRange:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def max(self) -> Optional[int]: ...
    @property
    def min(self) -> int: ...

class SequenceRepetition:
    class AdmitsEmpty:
        __members__: ClassVar[dict] = ...  # read-only
        Depends: ClassVar[SequenceRepetition.AdmitsEmpty] = ...
        No: ClassVar[SequenceRepetition.AdmitsEmpty] = ...
        Yes: ClassVar[SequenceRepetition.AdmitsEmpty] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Kind:
        __members__: ClassVar[dict] = ...  # read-only
        Consecutive: ClassVar[SequenceRepetition.Kind] = ...
        GoTo: ClassVar[SequenceRepetition.Kind] = ...
        Nonconsecutive: ClassVar[SequenceRepetition.Kind] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Consecutive: ClassVar[SequenceRepetition.Kind] = ...
    GoTo: ClassVar[SequenceRepetition.Kind] = ...
    Nonconsecutive: ClassVar[SequenceRepetition.Kind] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def admitsEmpty(self) -> Any: ...
    @property
    def kind(self) -> Any: ...
    @property
    def range(self) -> SequenceRange: ...

class SequenceRepetitionSyntax(SyntaxNode):
    closeBracket: Token
    op: Token
    openBracket: Token
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def ports(self) -> span[AssertionPortSymbol]: ...

class SequenceType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class SequenceWithMatchExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def matchItems(self) -> span[Expression]: ...
    @property
    def repetition(self) -> Optional[SequenceRepetition]: ...

class SetExprBinsSelectExpr(BinsSelectExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def matchesExpr(self) -> Expression: ...

class SignalEventControl(TimingControl):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def edge(self) -> Any: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def iffCondition(self) -> Expression: ...

class SignalEventExpressionSyntax(EventExpressionSyntax):
    edge: Token
    expr: ExpressionSyntax
    iffClause: IffEventClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SignedCastExpressionSyntax(ExpressionSyntax):
    apostrophe: Token
    inner: ParenthesizedExpressionSyntax
    signing: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> Expression: ...
    @property
    def repetition(self) -> Optional[SequenceRepetition]: ...

class SimpleAssignmentPatternExpression(AssignmentPatternExpressionBase):
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleAssignmentPatternSyntax(AssignmentPatternSyntax):
    closeBrace: Token
    items: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    expr: ExpressionSyntax
    matchesClause: MatchesClauseSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleDirectiveSyntax(DirectiveSyntax):
    def __init__(self, *args, **kwargs) -> None: ...

class SimplePathSuffixSyntax(PathSuffixSyntax):
    outputs: Any
    def __init__(self, *args, **kwargs) -> None: ...

class SimplePragmaExpressionSyntax(PragmaExpressionSyntax):
    value: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SimplePropertyExprSyntax(PropertyExprSyntax):
    expr: SequenceExprSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleSequenceExprSyntax(SequenceExprSyntax):
    expr: ExpressionSyntax
    repetition: SequenceRepetitionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SimpleSystemSubroutine(SystemSubroutine):
    def __init__(self, arg0: str, arg1: SubroutineKind, arg2: int, arg3, arg4, arg5: bool, arg6: bool) -> None: ...

class SolveBeforeConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def before(self) -> span[Expression]: ...
    @property
    def solve(self) -> span[Expression]: ...

class SolveBeforeConstraintSyntax(ConstraintItemSyntax):
    afterExpr: Any
    before: Token
    beforeExpr: Any
    semi: Token
    solve: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SourceBuffer:
    def __init__(self) -> None: ...
    def __bool__(self) -> bool: ...
    @property
    def data(self) -> str: ...
    @property
    def id(self) -> BufferID: ...

class SourceLocation:
    NoLocation: ClassVar[SourceLocation] = ...  # read-only
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: BufferID, arg1: int) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: SourceLocation) -> bool: ...
    def __ge__(self, arg0: SourceLocation) -> bool: ...
    def __gt__(self, arg0: SourceLocation) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, arg0: SourceLocation) -> bool: ...
    def __lt__(self, arg0: SourceLocation) -> bool: ...
    def __ne__(self, arg0: SourceLocation) -> bool: ...
    @property
    def buffer(self) -> BufferID: ...
    @property
    def offset(self) -> int: ...

class SourceManager:
    def __init__(self) -> None: ...
    def addDiagnosticDirective(self, arg0: SourceLocation, arg1: str, arg2) -> None: ...
    def addLineDirective(self, arg0: SourceLocation, arg1: int, arg2: str, arg3: int) -> None: ...
    def addSystemDirectory(self, arg0: str) -> None: ...
    def addUserDirectory(self, arg0: str) -> None: ...
    @overload
    def assignText(self, text: str, includedFrom: SourceLocation = ...) -> SourceBuffer: ...
    @overload
    def assignText(self, path: str, text: str, includedFrom: SourceLocation = ...) -> SourceBuffer: ...
    def getAllBuffers(self) -> List[BufferID]: ...
    def getColumnNumber(self, arg0: SourceLocation) -> int: ...
    def getExpansionLoc(self, arg0: SourceLocation) -> SourceLocation: ...
    def getExpansionRange(self, arg0: SourceLocation) -> SourceRange: ...
    def getFileName(self, arg0: SourceLocation) -> str: ...
    def getFullyExpandedLoc(self, arg0: SourceLocation) -> SourceLocation: ...
    def getFullyOriginalLoc(self, arg0: SourceLocation) -> SourceLocation: ...
    def getIncludedFrom(self, arg0: BufferID) -> SourceLocation: ...
    def getLineNumber(self, arg0: SourceLocation) -> int: ...
    def getMacroName(self, arg0: SourceLocation) -> str: ...
    def getOriginalLoc(self, arg0: SourceLocation) -> SourceLocation: ...
    def getRawFileName(self, arg0: BufferID) -> str: ...
    def getSourceText(self, arg0: BufferID) -> str: ...
    def isBeforeInCompilationUnit(self, arg0: SourceLocation, arg1: SourceLocation) -> bool: ...
    def isCached(self, arg0: os.PathLike) -> bool: ...
    def isFileLoc(self, arg0: SourceLocation) -> bool: ...
    def isIncludedFileLoc(self, arg0: SourceLocation) -> bool: ...
    def isMacroArgLoc(self, arg0: SourceLocation) -> bool: ...
    def isMacroLoc(self, arg0: SourceLocation) -> bool: ...
    def isPreprocessedLoc(self, arg0: SourceLocation) -> bool: ...
    def makeAbsolutePath(self, arg0: str) -> str: ...
    def readHeader(self, arg0: str, arg1: SourceLocation, arg2: bool) -> SourceBuffer: ...
    def readSource(self, arg0: os.PathLike) -> SourceBuffer: ...
    def setDisableProximatePaths(self, arg0: bool) -> None: ...

class SourceRange:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SourceLocation, arg1: SourceLocation) -> None: ...
    def __eq__(self, arg0: SourceRange) -> bool: ...
    def __ne__(self, arg0: SourceRange) -> bool: ...
    @property
    def end(self) -> SourceLocation: ...
    @property
    def start(self) -> SourceLocation: ...

class SpecifyBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...

class SpecifyBlockSyntax(MemberSyntax):
    endspecify: Token
    items: Any
    specify: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SpecparamDeclarationSyntax(MemberSyntax):
    declarators: Any
    keyword: Token
    semi: Token
    type: ImplicitTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SpecparamDeclaratorSyntax(SyntaxNode):
    equals: Token
    name: Token
    value: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class SpecparamSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> ConstantValue: ...

class StandardCaseItemSyntax(CaseItemSyntax):
    clause: SyntaxNode
    colon: Token
    expressions: Any
    def __init__(self, *args, **kwargs) -> None: ...

class StandardPropertyCaseItemSyntax(PropertyCaseItemSyntax):
    colon: Token
    expr: PropertyExprSyntax
    expressions: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StandardRsCaseItemSyntax(RsCaseItemSyntax):
    colon: Token
    expressions: Any
    item: RsProdItemSyntax
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Statement:
    class EvalResult:
        __members__: ClassVar[dict] = ...  # read-only
        Break: ClassVar[Statement.EvalResult] = ...
        Continue: ClassVar[Statement.EvalResult] = ...
        Disable: ClassVar[Statement.EvalResult] = ...
        Fail: ClassVar[Statement.EvalResult] = ...
        Return: ClassVar[Statement.EvalResult] = ...
        Success: ClassVar[Statement.EvalResult] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def eval(self, *args, **kwargs) -> Any: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> StatementKind: ...
    @property
    def sourceRange(self) -> Any: ...
    @property
    def syntax(self) -> Any: ...

class StatementBlockKind:
    __members__: ClassVar[dict] = ...  # read-only
    JoinAll: ClassVar[StatementBlockKind] = ...
    JoinAny: ClassVar[StatementBlockKind] = ...
    JoinNone: ClassVar[StatementBlockKind] = ...
    Sequential: ClassVar[StatementBlockKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StatementBlockSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def blockKind(self) -> StatementBlockKind: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...

class StatementKind:
    __members__: ClassVar[dict] = ...  # read-only
    Block: ClassVar[StatementKind] = ...
    Break: ClassVar[StatementKind] = ...
    Case: ClassVar[StatementKind] = ...
    ConcurrentAssertion: ClassVar[StatementKind] = ...
    Conditional: ClassVar[StatementKind] = ...
    Continue: ClassVar[StatementKind] = ...
    Disable: ClassVar[StatementKind] = ...
    DisableFork: ClassVar[StatementKind] = ...
    DoWhileLoop: ClassVar[StatementKind] = ...
    Empty: ClassVar[StatementKind] = ...
    EventTrigger: ClassVar[StatementKind] = ...
    ExpressionStatement: ClassVar[StatementKind] = ...
    ForLoop: ClassVar[StatementKind] = ...
    ForeachLoop: ClassVar[StatementKind] = ...
    ForeverLoop: ClassVar[StatementKind] = ...
    ImmediateAssertion: ClassVar[StatementKind] = ...
    Invalid: ClassVar[StatementKind] = ...
    List: ClassVar[StatementKind] = ...
    PatternCase: ClassVar[StatementKind] = ...
    ProceduralAssign: ClassVar[StatementKind] = ...
    ProceduralDeassign: ClassVar[StatementKind] = ...
    RandCase: ClassVar[StatementKind] = ...
    RandSequence: ClassVar[StatementKind] = ...
    RepeatLoop: ClassVar[StatementKind] = ...
    Return: ClassVar[StatementKind] = ...
    Timed: ClassVar[StatementKind] = ...
    VariableDeclaration: ClassVar[StatementKind] = ...
    Wait: ClassVar[StatementKind] = ...
    WaitFork: ClassVar[StatementKind] = ...
    WaitOrder: ClassVar[StatementKind] = ...
    WhileLoop: ClassVar[StatementKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class StatementList(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def list(self) -> span[Statement]: ...

class StatementSyntax(SyntaxNode):
    attributes: Any
    label: NamedLabelSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StreamExpressionSyntax(SyntaxNode):
    expression: ExpressionSyntax
    withRange: StreamExpressionWithRangeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StreamExpressionWithRangeSyntax(SyntaxNode):
    range: ElementSelectSyntax
    withKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StreamingConcatenationExpression(Expression):
    class StreamExpression:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def constantWithWidth(self) -> Optional[int]: ...
        @property
        def operand(self) -> Expression: ...
        @property
        def withExpr(self) -> Expression: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bitstreamWidth(self) -> int: ...
    @property
    def isFixedSize(self) -> bool: ...
    @property
    def sliceSize(self) -> int: ...
    @property
    def streams(self) -> Any: ...

class StreamingConcatenationExpressionSyntax(PrimaryExpressionSyntax):
    closeBrace: Token
    expressions: Any
    innerCloseBrace: Token
    innerOpenBrace: Token
    openBrace: Token
    operatorToken: Token
    sliceSize: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StringLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def intValue(self) -> Any: ...
    @property
    def rawValue(self) -> str: ...
    @property
    def value(self) -> str: ...

class StringType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class StrongWeakAssertionExpr(AssertionExpr):
    class Strength:
        __members__: ClassVar[dict] = ...  # read-only
        Strong: ClassVar[StrongWeakAssertionExpr.Strength] = ...
        Weak: ClassVar[StrongWeakAssertionExpr.Strength] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Strong: ClassVar[StrongWeakAssertionExpr.Strength] = ...
    Weak: ClassVar[StrongWeakAssertionExpr.Strength] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def strength(self) -> Any: ...

class StrongWeakPropertyExprSyntax(PropertyExprSyntax):
    closeParen: Token
    expr: SequenceExprSyntax
    keyword: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StructUnionMemberSyntax(SyntaxNode):
    attributes: Any
    declarators: Any
    randomQualifier: Token
    semi: Token
    type: DataTypeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class StructUnionTypeSyntax(DataTypeSyntax):
    closeBrace: Token
    dimensions: Any
    keyword: Token
    members: Any
    openBrace: Token
    packed: Token
    signing: Token
    tagged: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StructurePattern(Pattern):
    class FieldPattern:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def field(self) -> Any: ...
        @property
        def pattern(self) -> Pattern: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def patterns(self) -> Any: ...

class StructurePatternMemberSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class StructurePatternSyntax(PatternSyntax):
    closeBrace: Token
    members: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class StructuredAssignmentPatternExpression(AssignmentPatternExpressionBase):
    class IndexSetter:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def index(self) -> Expression: ...

    class MemberSetter:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def member(self) -> Any: ...

    class TypeSetter:
        def __init__(self, *args, **kwargs) -> None: ...
        @property
        def expr(self) -> Expression: ...
        @property
        def type(self) -> Any: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def defaultSetter(self) -> Expression: ...
    @property
    def indexSetters(self) -> Any: ...
    @property
    def memberSetters(self) -> Any: ...
    @property
    def typeSetters(self) -> Any: ...

class StructuredAssignmentPatternSyntax(AssignmentPatternSyntax):
    closeBrace: Token
    items: Any
    openBrace: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SubroutineKind:
    __members__: ClassVar[dict] = ...  # read-only
    Function: ClassVar[SubroutineKind] = ...
    Task: ClassVar[SubroutineKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SubroutineSymbol(Symbol, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def arguments(self) -> span[FormalArgumentSymbol]: ...
    @property
    def body(self) -> Statement: ...
    @property
    def defaultLifetime(self) -> VariableLifetime: ...
    @property
    def flags(self) -> MethodFlags: ...
    @property
    def isVirtual(self) -> bool: ...
    @property
    def override(self) -> SubroutineSymbol: ...
    @property
    def prototype(self) -> Any: ...
    @property
    def returnType(self) -> Any: ...
    @property
    def subroutineKind(self) -> SubroutineKind: ...
    @property
    def visibility(self) -> Visibility: ...

class Symbol:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def isDeclaredBefore(self, arg0: Symbol) -> Optional[bool]: ...
    @overload
    def isDeclaredBefore(self, arg0: LookupLocation) -> Optional[bool]: ...
    @property
    def declaringDefinition(self) -> Definition: ...
    @property
    def hierarchicalPath(self) -> str: ...
    @property
    def isScope(self) -> bool: ...
    @property
    def isType(self) -> bool: ...
    @property
    def isValue(self) -> bool: ...
    @property
    def kind(self) -> SymbolKind: ...
    @property
    def lexicalPath(self) -> str: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def name(self) -> str: ...
    @property
    def nextSibling(self) -> Symbol: ...
    @property
    def parentScope(self) -> Any: ...
    @property
    def randMode(self) -> RandMode: ...
    @property
    def syntax(self) -> Any: ...

class SymbolKind:
    __members__: ClassVar[dict] = ...  # read-only
    AssertionPort: ClassVar[SymbolKind] = ...
    AssociativeArrayType: ClassVar[SymbolKind] = ...
    Attribute: ClassVar[SymbolKind] = ...
    CHandleType: ClassVar[SymbolKind] = ...
    ClassProperty: ClassVar[SymbolKind] = ...
    ClassType: ClassVar[SymbolKind] = ...
    ClockVar: ClassVar[SymbolKind] = ...
    ClockingBlock: ClassVar[SymbolKind] = ...
    CompilationUnit: ClassVar[SymbolKind] = ...
    ConstraintBlock: ClassVar[SymbolKind] = ...
    ContinuousAssign: ClassVar[SymbolKind] = ...
    CoverCross: ClassVar[SymbolKind] = ...
    CoverCrossBody: ClassVar[SymbolKind] = ...
    CoverageBin: ClassVar[SymbolKind] = ...
    CovergroupBody: ClassVar[SymbolKind] = ...
    CovergroupType: ClassVar[SymbolKind] = ...
    Coverpoint: ClassVar[SymbolKind] = ...
    DefParam: ClassVar[SymbolKind] = ...
    DeferredMember: ClassVar[SymbolKind] = ...
    DynamicArrayType: ClassVar[SymbolKind] = ...
    ElabSystemTask: ClassVar[SymbolKind] = ...
    EmptyMember: ClassVar[SymbolKind] = ...
    EnumType: ClassVar[SymbolKind] = ...
    EnumValue: ClassVar[SymbolKind] = ...
    ErrorType: ClassVar[SymbolKind] = ...
    EventType: ClassVar[SymbolKind] = ...
    ExplicitImport: ClassVar[SymbolKind] = ...
    Field: ClassVar[SymbolKind] = ...
    FixedSizeUnpackedArrayType: ClassVar[SymbolKind] = ...
    FloatingType: ClassVar[SymbolKind] = ...
    FormalArgument: ClassVar[SymbolKind] = ...
    ForwardingTypedef: ClassVar[SymbolKind] = ...
    GenerateBlock: ClassVar[SymbolKind] = ...
    GenerateBlockArray: ClassVar[SymbolKind] = ...
    GenericClassDef: ClassVar[SymbolKind] = ...
    Genvar: ClassVar[SymbolKind] = ...
    Instance: ClassVar[SymbolKind] = ...
    InstanceArray: ClassVar[SymbolKind] = ...
    InstanceBody: ClassVar[SymbolKind] = ...
    InterfacePort: ClassVar[SymbolKind] = ...
    Iterator: ClassVar[SymbolKind] = ...
    LetDecl: ClassVar[SymbolKind] = ...
    LocalAssertionVar: ClassVar[SymbolKind] = ...
    MethodPrototype: ClassVar[SymbolKind] = ...
    Modport: ClassVar[SymbolKind] = ...
    ModportClocking: ClassVar[SymbolKind] = ...
    ModportPort: ClassVar[SymbolKind] = ...
    MultiPort: ClassVar[SymbolKind] = ...
    Net: ClassVar[SymbolKind] = ...
    NetType: ClassVar[SymbolKind] = ...
    NullType: ClassVar[SymbolKind] = ...
    Package: ClassVar[SymbolKind] = ...
    PackedArrayType: ClassVar[SymbolKind] = ...
    PackedStructType: ClassVar[SymbolKind] = ...
    PackedUnionType: ClassVar[SymbolKind] = ...
    Parameter: ClassVar[SymbolKind] = ...
    PatternVar: ClassVar[SymbolKind] = ...
    Port: ClassVar[SymbolKind] = ...
    PredefinedIntegerType: ClassVar[SymbolKind] = ...
    Primitive: ClassVar[SymbolKind] = ...
    PrimitiveInstance: ClassVar[SymbolKind] = ...
    PrimitivePort: ClassVar[SymbolKind] = ...
    ProceduralBlock: ClassVar[SymbolKind] = ...
    Property: ClassVar[SymbolKind] = ...
    PropertyType: ClassVar[SymbolKind] = ...
    QueueType: ClassVar[SymbolKind] = ...
    RandSeqProduction: ClassVar[SymbolKind] = ...
    Root: ClassVar[SymbolKind] = ...
    ScalarType: ClassVar[SymbolKind] = ...
    Sequence: ClassVar[SymbolKind] = ...
    SequenceType: ClassVar[SymbolKind] = ...
    SpecifyBlock: ClassVar[SymbolKind] = ...
    Specparam: ClassVar[SymbolKind] = ...
    StatementBlock: ClassVar[SymbolKind] = ...
    StringType: ClassVar[SymbolKind] = ...
    Subroutine: ClassVar[SymbolKind] = ...
    TransparentMember: ClassVar[SymbolKind] = ...
    TypeAlias: ClassVar[SymbolKind] = ...
    TypeParameter: ClassVar[SymbolKind] = ...
    TypeRefType: ClassVar[SymbolKind] = ...
    UnboundedType: ClassVar[SymbolKind] = ...
    Unknown: ClassVar[SymbolKind] = ...
    UnknownModule: ClassVar[SymbolKind] = ...
    UnpackedStructType: ClassVar[SymbolKind] = ...
    UnpackedUnionType: ClassVar[SymbolKind] = ...
    UntypedType: ClassVar[SymbolKind] = ...
    Variable: ClassVar[SymbolKind] = ...
    VirtualInterfaceType: ClassVar[SymbolKind] = ...
    VoidType: ClassVar[SymbolKind] = ...
    WildcardImport: ClassVar[SymbolKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SyntaxKind:
    __members__: ClassVar[dict] = ...  # read-only
    AcceptOnPropertyExpr: ClassVar[SyntaxKind] = ...
    ActionBlock: ClassVar[SyntaxKind] = ...
    AddAssignmentExpression: ClassVar[SyntaxKind] = ...
    AddExpression: ClassVar[SyntaxKind] = ...
    AlwaysBlock: ClassVar[SyntaxKind] = ...
    AlwaysCombBlock: ClassVar[SyntaxKind] = ...
    AlwaysFFBlock: ClassVar[SyntaxKind] = ...
    AlwaysLatchBlock: ClassVar[SyntaxKind] = ...
    AndAssignmentExpression: ClassVar[SyntaxKind] = ...
    AndPropertyExpr: ClassVar[SyntaxKind] = ...
    AndSequenceExpr: ClassVar[SyntaxKind] = ...
    AnsiPortList: ClassVar[SyntaxKind] = ...
    AnsiUdpPortList: ClassVar[SyntaxKind] = ...
    ArgumentList: ClassVar[SyntaxKind] = ...
    ArithmeticLeftShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    ArithmeticRightShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    ArithmeticShiftLeftExpression: ClassVar[SyntaxKind] = ...
    ArithmeticShiftRightExpression: ClassVar[SyntaxKind] = ...
    ArrayAndMethod: ClassVar[SyntaxKind] = ...
    ArrayOrMethod: ClassVar[SyntaxKind] = ...
    ArrayOrRandomizeMethodExpression: ClassVar[SyntaxKind] = ...
    ArrayUniqueMethod: ClassVar[SyntaxKind] = ...
    ArrayXorMethod: ClassVar[SyntaxKind] = ...
    AscendingRangeSelect: ClassVar[SyntaxKind] = ...
    AssertPropertyStatement: ClassVar[SyntaxKind] = ...
    AssertionItemPort: ClassVar[SyntaxKind] = ...
    AssertionItemPortList: ClassVar[SyntaxKind] = ...
    AssignmentExpression: ClassVar[SyntaxKind] = ...
    AssignmentPatternExpression: ClassVar[SyntaxKind] = ...
    AssignmentPatternItem: ClassVar[SyntaxKind] = ...
    AssumePropertyStatement: ClassVar[SyntaxKind] = ...
    AttributeInstance: ClassVar[SyntaxKind] = ...
    AttributeSpec: ClassVar[SyntaxKind] = ...
    BadExpression: ClassVar[SyntaxKind] = ...
    BeginKeywordsDirective: ClassVar[SyntaxKind] = ...
    BinSelectWithFilterExpr: ClassVar[SyntaxKind] = ...
    BinaryAndExpression: ClassVar[SyntaxKind] = ...
    BinaryBinsSelectExpr: ClassVar[SyntaxKind] = ...
    BinaryBlockEventExpression: ClassVar[SyntaxKind] = ...
    BinaryEventExpression: ClassVar[SyntaxKind] = ...
    BinaryOrExpression: ClassVar[SyntaxKind] = ...
    BinaryXnorExpression: ClassVar[SyntaxKind] = ...
    BinaryXorExpression: ClassVar[SyntaxKind] = ...
    BindDirective: ClassVar[SyntaxKind] = ...
    BindTargetList: ClassVar[SyntaxKind] = ...
    BinsSelectConditionExpr: ClassVar[SyntaxKind] = ...
    BinsSelection: ClassVar[SyntaxKind] = ...
    BitSelect: ClassVar[SyntaxKind] = ...
    BitType: ClassVar[SyntaxKind] = ...
    BlockCoverageEvent: ClassVar[SyntaxKind] = ...
    BlockingEventTriggerStatement: ClassVar[SyntaxKind] = ...
    ByteType: ClassVar[SyntaxKind] = ...
    CHandleType: ClassVar[SyntaxKind] = ...
    CaseEqualityExpression: ClassVar[SyntaxKind] = ...
    CaseGenerate: ClassVar[SyntaxKind] = ...
    CaseInequalityExpression: ClassVar[SyntaxKind] = ...
    CasePropertyExpr: ClassVar[SyntaxKind] = ...
    CaseStatement: ClassVar[SyntaxKind] = ...
    CastExpression: ClassVar[SyntaxKind] = ...
    CellConfigRule: ClassVar[SyntaxKind] = ...
    CellDefineDirective: ClassVar[SyntaxKind] = ...
    ChargeStrength: ClassVar[SyntaxKind] = ...
    CheckerDataDeclaration: ClassVar[SyntaxKind] = ...
    CheckerDeclaration: ClassVar[SyntaxKind] = ...
    CheckerInstanceStatement: ClassVar[SyntaxKind] = ...
    CheckerInstantiation: ClassVar[SyntaxKind] = ...
    ClassDeclaration: ClassVar[SyntaxKind] = ...
    ClassMethodDeclaration: ClassVar[SyntaxKind] = ...
    ClassMethodPrototype: ClassVar[SyntaxKind] = ...
    ClassName: ClassVar[SyntaxKind] = ...
    ClassPropertyDeclaration: ClassVar[SyntaxKind] = ...
    ClockingDeclaration: ClassVar[SyntaxKind] = ...
    ClockingDirection: ClassVar[SyntaxKind] = ...
    ClockingItem: ClassVar[SyntaxKind] = ...
    ClockingPropertyExpr: ClassVar[SyntaxKind] = ...
    ClockingSequenceExpr: ClassVar[SyntaxKind] = ...
    ClockingSkew: ClassVar[SyntaxKind] = ...
    ColonExpressionClause: ClassVar[SyntaxKind] = ...
    CompilationUnit: ClassVar[SyntaxKind] = ...
    ConcatenationExpression: ClassVar[SyntaxKind] = ...
    ConcurrentAssertionMember: ClassVar[SyntaxKind] = ...
    ConditionalConstraint: ClassVar[SyntaxKind] = ...
    ConditionalExpression: ClassVar[SyntaxKind] = ...
    ConditionalPathDeclaration: ClassVar[SyntaxKind] = ...
    ConditionalPattern: ClassVar[SyntaxKind] = ...
    ConditionalPredicate: ClassVar[SyntaxKind] = ...
    ConditionalPropertyExpr: ClassVar[SyntaxKind] = ...
    ConditionalStatement: ClassVar[SyntaxKind] = ...
    ConfigCellIdentifier: ClassVar[SyntaxKind] = ...
    ConfigDeclaration: ClassVar[SyntaxKind] = ...
    ConfigInstanceIdentifier: ClassVar[SyntaxKind] = ...
    ConfigLiblist: ClassVar[SyntaxKind] = ...
    ConfigUseClause: ClassVar[SyntaxKind] = ...
    ConstraintBlock: ClassVar[SyntaxKind] = ...
    ConstraintDeclaration: ClassVar[SyntaxKind] = ...
    ConstraintPrototype: ClassVar[SyntaxKind] = ...
    ConstructorName: ClassVar[SyntaxKind] = ...
    ContinuousAssign: ClassVar[SyntaxKind] = ...
    CopyClassExpression: ClassVar[SyntaxKind] = ...
    CoverCross: ClassVar[SyntaxKind] = ...
    CoverPropertyStatement: ClassVar[SyntaxKind] = ...
    CoverSequenceStatement: ClassVar[SyntaxKind] = ...
    CoverageBins: ClassVar[SyntaxKind] = ...
    CoverageBinsArraySize: ClassVar[SyntaxKind] = ...
    CoverageIffClause: ClassVar[SyntaxKind] = ...
    CoverageOption: ClassVar[SyntaxKind] = ...
    CovergroupDeclaration: ClassVar[SyntaxKind] = ...
    Coverpoint: ClassVar[SyntaxKind] = ...
    CycleDelay: ClassVar[SyntaxKind] = ...
    DPIExport: ClassVar[SyntaxKind] = ...
    DPIImport: ClassVar[SyntaxKind] = ...
    DataDeclaration: ClassVar[SyntaxKind] = ...
    Declarator: ClassVar[SyntaxKind] = ...
    DefParam: ClassVar[SyntaxKind] = ...
    DefParamAssignment: ClassVar[SyntaxKind] = ...
    DefaultCaseItem: ClassVar[SyntaxKind] = ...
    DefaultClockingReference: ClassVar[SyntaxKind] = ...
    DefaultConfigRule: ClassVar[SyntaxKind] = ...
    DefaultCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    DefaultDisableDeclaration: ClassVar[SyntaxKind] = ...
    DefaultNetTypeDirective: ClassVar[SyntaxKind] = ...
    DefaultPatternKeyExpression: ClassVar[SyntaxKind] = ...
    DefaultPropertyCaseItem: ClassVar[SyntaxKind] = ...
    DefaultRsCaseItem: ClassVar[SyntaxKind] = ...
    DefaultSkewItem: ClassVar[SyntaxKind] = ...
    DeferredAssertion: ClassVar[SyntaxKind] = ...
    DefineDirective: ClassVar[SyntaxKind] = ...
    Delay3: ClassVar[SyntaxKind] = ...
    DelayControl: ClassVar[SyntaxKind] = ...
    DelayedSequenceElement: ClassVar[SyntaxKind] = ...
    DelayedSequenceExpr: ClassVar[SyntaxKind] = ...
    DelayedTerminalArg: ClassVar[SyntaxKind] = ...
    DescendingRangeSelect: ClassVar[SyntaxKind] = ...
    DisableConstraint: ClassVar[SyntaxKind] = ...
    DisableForkStatement: ClassVar[SyntaxKind] = ...
    DisableIff: ClassVar[SyntaxKind] = ...
    DisableStatement: ClassVar[SyntaxKind] = ...
    DistConstraintList: ClassVar[SyntaxKind] = ...
    DistItem: ClassVar[SyntaxKind] = ...
    DistWeight: ClassVar[SyntaxKind] = ...
    DivideAssignmentExpression: ClassVar[SyntaxKind] = ...
    DivideExpression: ClassVar[SyntaxKind] = ...
    DividerClause: ClassVar[SyntaxKind] = ...
    DoWhileStatement: ClassVar[SyntaxKind] = ...
    DotMemberClause: ClassVar[SyntaxKind] = ...
    DriveStrength: ClassVar[SyntaxKind] = ...
    EdgeControlSpecifier: ClassVar[SyntaxKind] = ...
    EdgeDescriptor: ClassVar[SyntaxKind] = ...
    EdgeSensitivePathSuffix: ClassVar[SyntaxKind] = ...
    ElabSystemTask: ClassVar[SyntaxKind] = ...
    ElementSelect: ClassVar[SyntaxKind] = ...
    ElementSelectExpression: ClassVar[SyntaxKind] = ...
    ElsIfDirective: ClassVar[SyntaxKind] = ...
    ElseClause: ClassVar[SyntaxKind] = ...
    ElseConstraintClause: ClassVar[SyntaxKind] = ...
    ElseDirective: ClassVar[SyntaxKind] = ...
    ElsePropertyClause: ClassVar[SyntaxKind] = ...
    EmptyArgument: ClassVar[SyntaxKind] = ...
    EmptyIdentifierName: ClassVar[SyntaxKind] = ...
    EmptyMember: ClassVar[SyntaxKind] = ...
    EmptyNonAnsiPort: ClassVar[SyntaxKind] = ...
    EmptyPortConnection: ClassVar[SyntaxKind] = ...
    EmptyQueueExpression: ClassVar[SyntaxKind] = ...
    EmptyStatement: ClassVar[SyntaxKind] = ...
    EmptyTimingCheckArg: ClassVar[SyntaxKind] = ...
    EndCellDefineDirective: ClassVar[SyntaxKind] = ...
    EndIfDirective: ClassVar[SyntaxKind] = ...
    EndKeywordsDirective: ClassVar[SyntaxKind] = ...
    EnumType: ClassVar[SyntaxKind] = ...
    EqualityExpression: ClassVar[SyntaxKind] = ...
    EqualsAssertionArgClause: ClassVar[SyntaxKind] = ...
    EqualsTypeClause: ClassVar[SyntaxKind] = ...
    EqualsValueClause: ClassVar[SyntaxKind] = ...
    EventControl: ClassVar[SyntaxKind] = ...
    EventControlWithExpression: ClassVar[SyntaxKind] = ...
    EventType: ClassVar[SyntaxKind] = ...
    ExpectPropertyStatement: ClassVar[SyntaxKind] = ...
    ExplicitAnsiPort: ClassVar[SyntaxKind] = ...
    ExplicitNonAnsiPort: ClassVar[SyntaxKind] = ...
    ExpressionConstraint: ClassVar[SyntaxKind] = ...
    ExpressionCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    ExpressionOrDist: ClassVar[SyntaxKind] = ...
    ExpressionPattern: ClassVar[SyntaxKind] = ...
    ExpressionStatement: ClassVar[SyntaxKind] = ...
    ExpressionTimingCheckArg: ClassVar[SyntaxKind] = ...
    ExtendsClause: ClassVar[SyntaxKind] = ...
    ExternInterfaceMethod: ClassVar[SyntaxKind] = ...
    ExternModuleDecl: ClassVar[SyntaxKind] = ...
    ExternUdpDecl: ClassVar[SyntaxKind] = ...
    FinalBlock: ClassVar[SyntaxKind] = ...
    FirstMatchSequenceExpr: ClassVar[SyntaxKind] = ...
    FollowedByPropertyExpr: ClassVar[SyntaxKind] = ...
    ForLoopStatement: ClassVar[SyntaxKind] = ...
    ForVariableDeclaration: ClassVar[SyntaxKind] = ...
    ForeachLoopList: ClassVar[SyntaxKind] = ...
    ForeachLoopStatement: ClassVar[SyntaxKind] = ...
    ForeverStatement: ClassVar[SyntaxKind] = ...
    ForwardInterfaceClassTypedefDeclaration: ClassVar[SyntaxKind] = ...
    ForwardTypedefDeclaration: ClassVar[SyntaxKind] = ...
    FunctionDeclaration: ClassVar[SyntaxKind] = ...
    FunctionPort: ClassVar[SyntaxKind] = ...
    FunctionPortList: ClassVar[SyntaxKind] = ...
    FunctionPrototype: ClassVar[SyntaxKind] = ...
    GenerateBlock: ClassVar[SyntaxKind] = ...
    GenerateRegion: ClassVar[SyntaxKind] = ...
    GenvarDeclaration: ClassVar[SyntaxKind] = ...
    GreaterThanEqualExpression: ClassVar[SyntaxKind] = ...
    GreaterThanExpression: ClassVar[SyntaxKind] = ...
    HierarchicalInstance: ClassVar[SyntaxKind] = ...
    HierarchyInstantiation: ClassVar[SyntaxKind] = ...
    IdWithExprCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    IdentifierName: ClassVar[SyntaxKind] = ...
    IdentifierSelectName: ClassVar[SyntaxKind] = ...
    IfDefDirective: ClassVar[SyntaxKind] = ...
    IfGenerate: ClassVar[SyntaxKind] = ...
    IfNDefDirective: ClassVar[SyntaxKind] = ...
    IfNonePathDeclaration: ClassVar[SyntaxKind] = ...
    IffEventClause: ClassVar[SyntaxKind] = ...
    IffPropertyExpr: ClassVar[SyntaxKind] = ...
    ImmediateAssertStatement: ClassVar[SyntaxKind] = ...
    ImmediateAssertionMember: ClassVar[SyntaxKind] = ...
    ImmediateAssumeStatement: ClassVar[SyntaxKind] = ...
    ImmediateCoverStatement: ClassVar[SyntaxKind] = ...
    ImplementsClause: ClassVar[SyntaxKind] = ...
    ImplicationConstraint: ClassVar[SyntaxKind] = ...
    ImplicationPropertyExpr: ClassVar[SyntaxKind] = ...
    ImplicitAnsiPort: ClassVar[SyntaxKind] = ...
    ImplicitEventControl: ClassVar[SyntaxKind] = ...
    ImplicitNonAnsiPort: ClassVar[SyntaxKind] = ...
    ImplicitType: ClassVar[SyntaxKind] = ...
    ImpliesPropertyExpr: ClassVar[SyntaxKind] = ...
    IncludeDirective: ClassVar[SyntaxKind] = ...
    InequalityExpression: ClassVar[SyntaxKind] = ...
    InitialBlock: ClassVar[SyntaxKind] = ...
    InsideExpression: ClassVar[SyntaxKind] = ...
    InstanceConfigRule: ClassVar[SyntaxKind] = ...
    InstanceName: ClassVar[SyntaxKind] = ...
    IntType: ClassVar[SyntaxKind] = ...
    IntegerLiteralExpression: ClassVar[SyntaxKind] = ...
    IntegerType: ClassVar[SyntaxKind] = ...
    IntegerVectorExpression: ClassVar[SyntaxKind] = ...
    InterfaceDeclaration: ClassVar[SyntaxKind] = ...
    InterfaceHeader: ClassVar[SyntaxKind] = ...
    InterfacePortHeader: ClassVar[SyntaxKind] = ...
    IntersectClause: ClassVar[SyntaxKind] = ...
    IntersectSequenceExpr: ClassVar[SyntaxKind] = ...
    InvocationExpression: ClassVar[SyntaxKind] = ...
    JumpStatement: ClassVar[SyntaxKind] = ...
    LessThanEqualExpression: ClassVar[SyntaxKind] = ...
    LessThanExpression: ClassVar[SyntaxKind] = ...
    LetDeclaration: ClassVar[SyntaxKind] = ...
    LineDirective: ClassVar[SyntaxKind] = ...
    LocalScope: ClassVar[SyntaxKind] = ...
    LocalVariableDeclaration: ClassVar[SyntaxKind] = ...
    LogicType: ClassVar[SyntaxKind] = ...
    LogicalAndExpression: ClassVar[SyntaxKind] = ...
    LogicalEquivalenceExpression: ClassVar[SyntaxKind] = ...
    LogicalImplicationExpression: ClassVar[SyntaxKind] = ...
    LogicalLeftShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    LogicalOrExpression: ClassVar[SyntaxKind] = ...
    LogicalRightShiftAssignmentExpression: ClassVar[SyntaxKind] = ...
    LogicalShiftLeftExpression: ClassVar[SyntaxKind] = ...
    LogicalShiftRightExpression: ClassVar[SyntaxKind] = ...
    LongIntType: ClassVar[SyntaxKind] = ...
    LoopConstraint: ClassVar[SyntaxKind] = ...
    LoopGenerate: ClassVar[SyntaxKind] = ...
    LoopStatement: ClassVar[SyntaxKind] = ...
    MacroActualArgument: ClassVar[SyntaxKind] = ...
    MacroActualArgumentList: ClassVar[SyntaxKind] = ...
    MacroArgumentDefault: ClassVar[SyntaxKind] = ...
    MacroFormalArgument: ClassVar[SyntaxKind] = ...
    MacroFormalArgumentList: ClassVar[SyntaxKind] = ...
    MacroUsage: ClassVar[SyntaxKind] = ...
    MatchesClause: ClassVar[SyntaxKind] = ...
    MemberAccessExpression: ClassVar[SyntaxKind] = ...
    MinTypMaxExpression: ClassVar[SyntaxKind] = ...
    ModAssignmentExpression: ClassVar[SyntaxKind] = ...
    ModExpression: ClassVar[SyntaxKind] = ...
    ModportClockingPort: ClassVar[SyntaxKind] = ...
    ModportDeclaration: ClassVar[SyntaxKind] = ...
    ModportExplicitPort: ClassVar[SyntaxKind] = ...
    ModportItem: ClassVar[SyntaxKind] = ...
    ModportNamedPort: ClassVar[SyntaxKind] = ...
    ModportSimplePortList: ClassVar[SyntaxKind] = ...
    ModportSubroutinePort: ClassVar[SyntaxKind] = ...
    ModportSubroutinePortList: ClassVar[SyntaxKind] = ...
    ModuleDeclaration: ClassVar[SyntaxKind] = ...
    ModuleHeader: ClassVar[SyntaxKind] = ...
    MultipleConcatenationExpression: ClassVar[SyntaxKind] = ...
    MultiplyAssignmentExpression: ClassVar[SyntaxKind] = ...
    MultiplyExpression: ClassVar[SyntaxKind] = ...
    NameValuePragmaExpression: ClassVar[SyntaxKind] = ...
    NamedArgument: ClassVar[SyntaxKind] = ...
    NamedBlockClause: ClassVar[SyntaxKind] = ...
    NamedLabel: ClassVar[SyntaxKind] = ...
    NamedParamAssignment: ClassVar[SyntaxKind] = ...
    NamedPortConnection: ClassVar[SyntaxKind] = ...
    NamedStructurePatternMember: ClassVar[SyntaxKind] = ...
    NamedType: ClassVar[SyntaxKind] = ...
    NetAlias: ClassVar[SyntaxKind] = ...
    NetDeclaration: ClassVar[SyntaxKind] = ...
    NetPortHeader: ClassVar[SyntaxKind] = ...
    NetTypeDeclaration: ClassVar[SyntaxKind] = ...
    NewArrayExpression: ClassVar[SyntaxKind] = ...
    NewClassExpression: ClassVar[SyntaxKind] = ...
    NoUnconnectedDriveDirective: ClassVar[SyntaxKind] = ...
    NonAnsiPortList: ClassVar[SyntaxKind] = ...
    NonAnsiUdpPortList: ClassVar[SyntaxKind] = ...
    NonblockingAssignmentExpression: ClassVar[SyntaxKind] = ...
    NonblockingEventTriggerStatement: ClassVar[SyntaxKind] = ...
    NullLiteralExpression: ClassVar[SyntaxKind] = ...
    NumberPragmaExpression: ClassVar[SyntaxKind] = ...
    OneStepDelay: ClassVar[SyntaxKind] = ...
    OpenRangeExpression: ClassVar[SyntaxKind] = ...
    OpenRangeList: ClassVar[SyntaxKind] = ...
    OrAssignmentExpression: ClassVar[SyntaxKind] = ...
    OrPropertyExpr: ClassVar[SyntaxKind] = ...
    OrSequenceExpr: ClassVar[SyntaxKind] = ...
    OrderedArgument: ClassVar[SyntaxKind] = ...
    OrderedParamAssignment: ClassVar[SyntaxKind] = ...
    OrderedPortConnection: ClassVar[SyntaxKind] = ...
    OrderedStructurePatternMember: ClassVar[SyntaxKind] = ...
    PackageDeclaration: ClassVar[SyntaxKind] = ...
    PackageExportAllDeclaration: ClassVar[SyntaxKind] = ...
    PackageExportDeclaration: ClassVar[SyntaxKind] = ...
    PackageHeader: ClassVar[SyntaxKind] = ...
    PackageImportDeclaration: ClassVar[SyntaxKind] = ...
    PackageImportItem: ClassVar[SyntaxKind] = ...
    ParallelBlockStatement: ClassVar[SyntaxKind] = ...
    ParameterDeclaration: ClassVar[SyntaxKind] = ...
    ParameterDeclarationStatement: ClassVar[SyntaxKind] = ...
    ParameterPortList: ClassVar[SyntaxKind] = ...
    ParameterValueAssignment: ClassVar[SyntaxKind] = ...
    ParenExpressionList: ClassVar[SyntaxKind] = ...
    ParenPragmaExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedBinsSelectExpr: ClassVar[SyntaxKind] = ...
    ParenthesizedEventExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedExpression: ClassVar[SyntaxKind] = ...
    ParenthesizedPattern: ClassVar[SyntaxKind] = ...
    ParenthesizedPropertyExpr: ClassVar[SyntaxKind] = ...
    ParenthesizedSequenceExpr: ClassVar[SyntaxKind] = ...
    PathDeclaration: ClassVar[SyntaxKind] = ...
    PathDescription: ClassVar[SyntaxKind] = ...
    PatternCaseItem: ClassVar[SyntaxKind] = ...
    PortConcatenation: ClassVar[SyntaxKind] = ...
    PortDeclaration: ClassVar[SyntaxKind] = ...
    PortReference: ClassVar[SyntaxKind] = ...
    PostdecrementExpression: ClassVar[SyntaxKind] = ...
    PostincrementExpression: ClassVar[SyntaxKind] = ...
    PowerExpression: ClassVar[SyntaxKind] = ...
    PragmaDirective: ClassVar[SyntaxKind] = ...
    PrimaryBlockEventExpression: ClassVar[SyntaxKind] = ...
    PrimitiveInstantiation: ClassVar[SyntaxKind] = ...
    ProceduralAssignStatement: ClassVar[SyntaxKind] = ...
    ProceduralDeassignStatement: ClassVar[SyntaxKind] = ...
    ProceduralForceStatement: ClassVar[SyntaxKind] = ...
    ProceduralReleaseStatement: ClassVar[SyntaxKind] = ...
    Production: ClassVar[SyntaxKind] = ...
    ProgramDeclaration: ClassVar[SyntaxKind] = ...
    ProgramHeader: ClassVar[SyntaxKind] = ...
    PropertyDeclaration: ClassVar[SyntaxKind] = ...
    PropertySpec: ClassVar[SyntaxKind] = ...
    PropertyType: ClassVar[SyntaxKind] = ...
    PullStrength: ClassVar[SyntaxKind] = ...
    PulseStyleDeclaration: ClassVar[SyntaxKind] = ...
    QueueDimensionSpecifier: ClassVar[SyntaxKind] = ...
    RandCaseItem: ClassVar[SyntaxKind] = ...
    RandCaseStatement: ClassVar[SyntaxKind] = ...
    RandJoinClause: ClassVar[SyntaxKind] = ...
    RandSequenceStatement: ClassVar[SyntaxKind] = ...
    RangeCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    RangeDimensionSpecifier: ClassVar[SyntaxKind] = ...
    RealLiteralExpression: ClassVar[SyntaxKind] = ...
    RealTimeType: ClassVar[SyntaxKind] = ...
    RealType: ClassVar[SyntaxKind] = ...
    RegType: ClassVar[SyntaxKind] = ...
    RepeatedEventControl: ClassVar[SyntaxKind] = ...
    ReplicatedAssignmentPattern: ClassVar[SyntaxKind] = ...
    ResetAllDirective: ClassVar[SyntaxKind] = ...
    RestrictPropertyStatement: ClassVar[SyntaxKind] = ...
    ReturnStatement: ClassVar[SyntaxKind] = ...
    RootScope: ClassVar[SyntaxKind] = ...
    RsCase: ClassVar[SyntaxKind] = ...
    RsCodeBlock: ClassVar[SyntaxKind] = ...
    RsElseClause: ClassVar[SyntaxKind] = ...
    RsIfElse: ClassVar[SyntaxKind] = ...
    RsProdItem: ClassVar[SyntaxKind] = ...
    RsRepeat: ClassVar[SyntaxKind] = ...
    RsRule: ClassVar[SyntaxKind] = ...
    RsWeightClause: ClassVar[SyntaxKind] = ...
    SUntilPropertyExpr: ClassVar[SyntaxKind] = ...
    SUntilWithPropertyExpr: ClassVar[SyntaxKind] = ...
    ScopedName: ClassVar[SyntaxKind] = ...
    SeparatedList: ClassVar[SyntaxKind] = ...
    SequenceDeclaration: ClassVar[SyntaxKind] = ...
    SequenceMatchList: ClassVar[SyntaxKind] = ...
    SequenceRepetition: ClassVar[SyntaxKind] = ...
    SequenceType: ClassVar[SyntaxKind] = ...
    SequentialBlockStatement: ClassVar[SyntaxKind] = ...
    ShortIntType: ClassVar[SyntaxKind] = ...
    ShortRealType: ClassVar[SyntaxKind] = ...
    SignalEventExpression: ClassVar[SyntaxKind] = ...
    SignedCastExpression: ClassVar[SyntaxKind] = ...
    SimpleAssignmentPattern: ClassVar[SyntaxKind] = ...
    SimpleBinsSelectExpr: ClassVar[SyntaxKind] = ...
    SimplePathSuffix: ClassVar[SyntaxKind] = ...
    SimplePragmaExpression: ClassVar[SyntaxKind] = ...
    SimplePropertyExpr: ClassVar[SyntaxKind] = ...
    SimpleRangeSelect: ClassVar[SyntaxKind] = ...
    SimpleSequenceExpr: ClassVar[SyntaxKind] = ...
    SolveBeforeConstraint: ClassVar[SyntaxKind] = ...
    SpecifyBlock: ClassVar[SyntaxKind] = ...
    SpecparamDeclaration: ClassVar[SyntaxKind] = ...
    SpecparamDeclarator: ClassVar[SyntaxKind] = ...
    StandardCaseItem: ClassVar[SyntaxKind] = ...
    StandardPropertyCaseItem: ClassVar[SyntaxKind] = ...
    StandardRsCaseItem: ClassVar[SyntaxKind] = ...
    StreamExpression: ClassVar[SyntaxKind] = ...
    StreamExpressionWithRange: ClassVar[SyntaxKind] = ...
    StreamingConcatenationExpression: ClassVar[SyntaxKind] = ...
    StringLiteralExpression: ClassVar[SyntaxKind] = ...
    StringType: ClassVar[SyntaxKind] = ...
    StrongWeakPropertyExpr: ClassVar[SyntaxKind] = ...
    StructType: ClassVar[SyntaxKind] = ...
    StructUnionMember: ClassVar[SyntaxKind] = ...
    StructurePattern: ClassVar[SyntaxKind] = ...
    StructuredAssignmentPattern: ClassVar[SyntaxKind] = ...
    SubtractAssignmentExpression: ClassVar[SyntaxKind] = ...
    SubtractExpression: ClassVar[SyntaxKind] = ...
    SuperHandle: ClassVar[SyntaxKind] = ...
    SyntaxList: ClassVar[SyntaxKind] = ...
    SystemName: ClassVar[SyntaxKind] = ...
    SystemTimingCheck: ClassVar[SyntaxKind] = ...
    TaggedPattern: ClassVar[SyntaxKind] = ...
    TaggedUnionExpression: ClassVar[SyntaxKind] = ...
    TaskDeclaration: ClassVar[SyntaxKind] = ...
    ThisHandle: ClassVar[SyntaxKind] = ...
    ThroughoutSequenceExpr: ClassVar[SyntaxKind] = ...
    TimeLiteralExpression: ClassVar[SyntaxKind] = ...
    TimeScaleDirective: ClassVar[SyntaxKind] = ...
    TimeType: ClassVar[SyntaxKind] = ...
    TimeUnitsDeclaration: ClassVar[SyntaxKind] = ...
    TimingCheckCondition: ClassVar[SyntaxKind] = ...
    TimingCheckEvent: ClassVar[SyntaxKind] = ...
    TimingControlExpression: ClassVar[SyntaxKind] = ...
    TimingControlStatement: ClassVar[SyntaxKind] = ...
    TokenList: ClassVar[SyntaxKind] = ...
    TransListCoverageBinInitializer: ClassVar[SyntaxKind] = ...
    TransRange: ClassVar[SyntaxKind] = ...
    TransRepeatRange: ClassVar[SyntaxKind] = ...
    TransSet: ClassVar[SyntaxKind] = ...
    TypeAssignment: ClassVar[SyntaxKind] = ...
    TypeParameterDeclaration: ClassVar[SyntaxKind] = ...
    TypeReference: ClassVar[SyntaxKind] = ...
    TypedefDeclaration: ClassVar[SyntaxKind] = ...
    UdpBody: ClassVar[SyntaxKind] = ...
    UdpDeclaration: ClassVar[SyntaxKind] = ...
    UdpEdgeIndicator: ClassVar[SyntaxKind] = ...
    UdpEntry: ClassVar[SyntaxKind] = ...
    UdpInitialStmt: ClassVar[SyntaxKind] = ...
    UdpInputPortDecl: ClassVar[SyntaxKind] = ...
    UdpOutputPortDecl: ClassVar[SyntaxKind] = ...
    UnaryBinsSelectExpr: ClassVar[SyntaxKind] = ...
    UnaryBitwiseAndExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseNandExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseNorExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseNotExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseOrExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseXnorExpression: ClassVar[SyntaxKind] = ...
    UnaryBitwiseXorExpression: ClassVar[SyntaxKind] = ...
    UnaryLogicalNotExpression: ClassVar[SyntaxKind] = ...
    UnaryMinusExpression: ClassVar[SyntaxKind] = ...
    UnaryPlusExpression: ClassVar[SyntaxKind] = ...
    UnaryPredecrementExpression: ClassVar[SyntaxKind] = ...
    UnaryPreincrementExpression: ClassVar[SyntaxKind] = ...
    UnaryPropertyExpr: ClassVar[SyntaxKind] = ...
    UnarySelectPropertyExpr: ClassVar[SyntaxKind] = ...
    UnbasedUnsizedLiteralExpression: ClassVar[SyntaxKind] = ...
    UnconnectedDriveDirective: ClassVar[SyntaxKind] = ...
    UndefDirective: ClassVar[SyntaxKind] = ...
    UndefineAllDirective: ClassVar[SyntaxKind] = ...
    UnionType: ClassVar[SyntaxKind] = ...
    UniquenessConstraint: ClassVar[SyntaxKind] = ...
    UnitScope: ClassVar[SyntaxKind] = ...
    Unknown: ClassVar[SyntaxKind] = ...
    UntilPropertyExpr: ClassVar[SyntaxKind] = ...
    UntilWithPropertyExpr: ClassVar[SyntaxKind] = ...
    Untyped: ClassVar[SyntaxKind] = ...
    UserDefinedNetDeclaration: ClassVar[SyntaxKind] = ...
    VariableDimension: ClassVar[SyntaxKind] = ...
    VariablePattern: ClassVar[SyntaxKind] = ...
    VariablePortHeader: ClassVar[SyntaxKind] = ...
    VirtualInterfaceType: ClassVar[SyntaxKind] = ...
    VoidCastedCallStatement: ClassVar[SyntaxKind] = ...
    VoidType: ClassVar[SyntaxKind] = ...
    WaitForkStatement: ClassVar[SyntaxKind] = ...
    WaitOrderStatement: ClassVar[SyntaxKind] = ...
    WaitStatement: ClassVar[SyntaxKind] = ...
    WildcardDimensionSpecifier: ClassVar[SyntaxKind] = ...
    WildcardEqualityExpression: ClassVar[SyntaxKind] = ...
    WildcardInequalityExpression: ClassVar[SyntaxKind] = ...
    WildcardLiteralExpression: ClassVar[SyntaxKind] = ...
    WildcardPattern: ClassVar[SyntaxKind] = ...
    WildcardPortConnection: ClassVar[SyntaxKind] = ...
    WildcardPortList: ClassVar[SyntaxKind] = ...
    WildcardUdpPortList: ClassVar[SyntaxKind] = ...
    WithClause: ClassVar[SyntaxKind] = ...
    WithFunctionClause: ClassVar[SyntaxKind] = ...
    WithFunctionSample: ClassVar[SyntaxKind] = ...
    WithinSequenceExpr: ClassVar[SyntaxKind] = ...
    XorAssignmentExpression: ClassVar[SyntaxKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SyntaxNode:
    def __init__(self, *args, **kwargs) -> None: ...
    def getFirstToken(self) -> Token: ...
    def getLastToken(self) -> Token: ...
    def __getitem__(self, arg0: int) -> object: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    @property
    def kind(self) -> SyntaxKind: ...
    @property
    def parent(self) -> SyntaxNode: ...
    @property
    def sourceRange(self) -> SourceRange: ...

class SyntaxPrinter:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: SourceManager) -> None: ...
    @overload
    def print(self, arg0: Trivia) -> SyntaxPrinter: ...
    @overload
    def print(self, arg0: Token) -> SyntaxPrinter: ...
    @overload
    def print(self, arg0: SyntaxNode) -> SyntaxPrinter: ...
    @overload
    def print(self, arg0: SyntaxTree) -> SyntaxPrinter: ...
    def printFile(self, *args, **kwargs) -> Any: ...
    def setIncludeComments(self, arg0: bool) -> SyntaxPrinter: ...
    def setIncludeDirectives(self, arg0: bool) -> SyntaxPrinter: ...
    def setIncludeMissing(self, arg0: bool) -> SyntaxPrinter: ...
    def setIncludePreprocessed(self, arg0: bool) -> SyntaxPrinter: ...
    def setIncludeSkipped(self, arg0: bool) -> SyntaxPrinter: ...
    def setIncludeTrivia(self, arg0: bool) -> SyntaxPrinter: ...
    def setSquashNewlines(self, arg0: bool) -> SyntaxPrinter: ...
    def str(self) -> str: ...

class SyntaxTree:
    def __init__(self, *args, **kwargs) -> None: ...
    def fromBuffer(self, *args, **kwargs) -> Any: ...
    def fromBuffers(self, *args, **kwargs) -> Any: ...
    def fromFile(self, *args, **kwargs) -> Any: ...
    def fromFileInMemory(self, *args, **kwargs) -> Any: ...
    def fromFiles(self, *args, **kwargs) -> Any: ...
    def fromText(self, *args, **kwargs) -> Any: ...
    def getDefaultSourceManager(self, *args, **kwargs) -> Any: ...
    @property
    def diagnostics(self) -> Diagnostics: ...
    @property
    def isLibrary(self) -> bool: ...
    @property
    def options(self) -> Bag: ...
    @property
    def root(self) -> SyntaxNode: ...
    @property
    def sourceManager(self) -> SourceManager: ...

class SystemNameSyntax(NameSyntax):
    systemIdentifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class SystemSubroutine:
    class WithClauseMode:
        __members__: ClassVar[dict] = ...  # read-only
        Iterator: ClassVar[SystemSubroutine.WithClauseMode] = ...
        None: ClassVar[SystemSubroutine.WithClauseMode] = ...
        Randomize: ClassVar[SystemSubroutine.WithClauseMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    hasOutputArgs: bool
    kind: SubroutineKind
    name: str
    withClauseMode: Any
    def __init__(self, arg0: str, arg1: SubroutineKind) -> None: ...
    def allowClockingArgument(self, arg0: int) -> bool: ...
    def allowEmptyArgument(self, arg0: int) -> bool: ...
    def badArg(self, *args, **kwargs) -> Any: ...
    def bindArgument(self, arg0: int, arg1: ASTContext, arg2, arg3: span[Expression]) -> Expression: ...
    def checkArgCount(self, arg0: ASTContext, arg1: bool, arg2: span[Expression], arg3, arg4: int, arg5: int) -> bool: ...
    def checkArguments(self, *args, **kwargs) -> Any: ...
    def eval(self, *args, **kwargs) -> Any: ...
    def kindStr(self) -> str: ...
    def noHierarchical(self, arg0: EvalContext, arg1: Expression) -> bool: ...
    def notConst(self, arg0: EvalContext, arg1) -> bool: ...
    def unevaluatedContext(self) -> ASTContext: ...

class SystemTimingCheckSyntax(MemberSyntax):
    args: Any
    closeParen: Token
    name: Token
    openParen: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TaggedPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def member(self) -> Any: ...
    @property
    def valuePattern(self) -> Pattern: ...

class TaggedPatternSyntax(PatternSyntax):
    memberName: Token
    pattern: PatternSyntax
    tagged: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TaggedUnionExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def member(self) -> Any: ...
    @property
    def valueExpr(self) -> Expression: ...

class TaggedUnionExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    member: Token
    tagged: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TempVarSymbol(VariableSymbol):
    def __init__(self, *args, **kwargs) -> None: ...

class TextDiagnosticClient(DiagnosticClient):
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def getString(self) -> str: ...
    def report(self, arg0: ReportedDiagnostic) -> None: ...
    def showColors(self, arg0: bool) -> None: ...
    def showColumn(self, arg0: bool) -> None: ...
    def showHierarchyInstance(self, arg0: bool) -> None: ...
    def showIncludeStack(self, arg0: bool) -> None: ...
    def showLocation(self, arg0: bool) -> None: ...
    def showMacroExpansion(self, arg0: bool) -> None: ...
    def showOptionName(self, arg0: bool) -> None: ...
    def showSourceLine(self, arg0: bool) -> None: ...

class TimeLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def value(self) -> float: ...

class TimeScale:
    __hash__: ClassVar[None] = ...
    base: TimeScaleValue
    precision: TimeScaleValue
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TimeScaleValue, arg1: TimeScaleValue) -> None: ...
    def apply(self, arg0: float, arg1: TimeUnit) -> float: ...
    def __eq__(self, arg0: TimeScale) -> bool: ...
    def __ne__(self, arg0: TimeScale) -> bool: ...

class TimeScaleDirectiveSyntax(DirectiveSyntax):
    slash: Token
    timePrecision: Token
    timeUnit: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TimeScaleMagnitude:
    __members__: ClassVar[dict] = ...  # read-only
    Hundred: ClassVar[TimeScaleMagnitude] = ...
    One: ClassVar[TimeScaleMagnitude] = ...
    Ten: ClassVar[TimeScaleMagnitude] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimeScaleValue:
    __hash__: ClassVar[None] = ...
    magnitude: TimeScaleMagnitude
    unit: TimeUnit
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TimeUnit, arg1: TimeScaleMagnitude) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def fromLiteral(self, *args, **kwargs) -> Any: ...
    def __eq__(self, arg0: TimeScaleValue) -> bool: ...
    def __ne__(self, arg0: TimeScaleValue) -> bool: ...

class TimeUnit:
    __members__: ClassVar[dict] = ...  # read-only
    Femtoseconds: ClassVar[TimeUnit] = ...
    Microseconds: ClassVar[TimeUnit] = ...
    Milliseconds: ClassVar[TimeUnit] = ...
    Nanoseconds: ClassVar[TimeUnit] = ...
    Picoseconds: ClassVar[TimeUnit] = ...
    Seconds: ClassVar[TimeUnit] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimeUnitsDeclarationSyntax(MemberSyntax):
    divider: DividerClauseSyntax
    keyword: Token
    semi: Token
    time: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TimedStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def stmt(self) -> Statement: ...
    @property
    def timing(self) -> Any: ...

class TimingCheckArgSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class TimingCheckConditionSyntax(SyntaxNode):
    expr: ExpressionSyntax
    tripleAnd: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TimingCheckEventSyntax(TimingCheckArgSyntax):
    condition: TimingCheckConditionSyntax
    controlSpecifier: EdgeControlSpecifierSyntax
    edge: Token
    terminal: NameSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TimingControl:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def bad(self) -> bool: ...
    @property
    def kind(self) -> TimingControlKind: ...
    @property
    def sourceRange(self) -> Any: ...
    @property
    def syntax(self) -> Any: ...

class TimingControlExpressionSyntax(ExpressionSyntax):
    expr: ExpressionSyntax
    timing: TimingControlSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TimingControlKind:
    __members__: ClassVar[dict] = ...  # read-only
    BlockEventList: ClassVar[TimingControlKind] = ...
    CycleDelay: ClassVar[TimingControlKind] = ...
    Delay: ClassVar[TimingControlKind] = ...
    Delay3: ClassVar[TimingControlKind] = ...
    EventList: ClassVar[TimingControlKind] = ...
    ImplicitEvent: ClassVar[TimingControlKind] = ...
    Invalid: ClassVar[TimingControlKind] = ...
    OneStepDelay: ClassVar[TimingControlKind] = ...
    RepeatedEvent: ClassVar[TimingControlKind] = ...
    SignalEvent: ClassVar[TimingControlKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TimingControlStatementSyntax(StatementSyntax):
    statement: StatementSyntax
    timingControl: TimingControlSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TimingControlSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class Token:
    __hash__: ClassVar[None] = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation, arg5: str) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation, arg5: SyntaxKind) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation, arg5: logic_t) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation, arg5: SVInt) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation, arg5: float, arg6: bool, arg7: Optional[TimeUnit]) -> None: ...
    @overload
    def __init__(self, arg0: BumpAllocator, arg1: TokenKind, arg2: span[Trivia], arg3: str, arg4: SourceLocation, arg5: LiteralBase, arg6: bool) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: Token) -> bool: ...
    def __ne__(self, arg0: Token) -> bool: ...
    @property
    def isMissing(self) -> bool: ...
    @property
    def isOnSameLine(self) -> bool: ...
    @property
    def kind(self) -> TokenKind: ...
    @property
    def location(self) -> SourceLocation: ...
    @property
    def range(self) -> SourceRange: ...
    @property
    def rawText(self) -> str: ...
    @property
    def trivia(self) -> span[Trivia]: ...
    @property
    def value(self) -> object: ...
    @property
    def valueText(self) -> str: ...

class TokenKind:
    __members__: ClassVar[dict] = ...  # read-only
    AcceptOnKeyword: ClassVar[TokenKind] = ...
    AliasKeyword: ClassVar[TokenKind] = ...
    AlwaysCombKeyword: ClassVar[TokenKind] = ...
    AlwaysFFKeyword: ClassVar[TokenKind] = ...
    AlwaysKeyword: ClassVar[TokenKind] = ...
    AlwaysLatchKeyword: ClassVar[TokenKind] = ...
    And: ClassVar[TokenKind] = ...
    AndEqual: ClassVar[TokenKind] = ...
    AndKeyword: ClassVar[TokenKind] = ...
    Apostrophe: ClassVar[TokenKind] = ...
    ApostropheOpenBrace: ClassVar[TokenKind] = ...
    AssertKeyword: ClassVar[TokenKind] = ...
    AssignKeyword: ClassVar[TokenKind] = ...
    AssumeKeyword: ClassVar[TokenKind] = ...
    At: ClassVar[TokenKind] = ...
    AutomaticKeyword: ClassVar[TokenKind] = ...
    BeforeKeyword: ClassVar[TokenKind] = ...
    BeginKeyword: ClassVar[TokenKind] = ...
    BindKeyword: ClassVar[TokenKind] = ...
    BinsKeyword: ClassVar[TokenKind] = ...
    BinsOfKeyword: ClassVar[TokenKind] = ...
    BitKeyword: ClassVar[TokenKind] = ...
    BreakKeyword: ClassVar[TokenKind] = ...
    BufIf0Keyword: ClassVar[TokenKind] = ...
    BufIf1Keyword: ClassVar[TokenKind] = ...
    BufKeyword: ClassVar[TokenKind] = ...
    ByteKeyword: ClassVar[TokenKind] = ...
    CHandleKeyword: ClassVar[TokenKind] = ...
    CaseKeyword: ClassVar[TokenKind] = ...
    CaseXKeyword: ClassVar[TokenKind] = ...
    CaseZKeyword: ClassVar[TokenKind] = ...
    CellKeyword: ClassVar[TokenKind] = ...
    CheckerKeyword: ClassVar[TokenKind] = ...
    ClassKeyword: ClassVar[TokenKind] = ...
    ClockingKeyword: ClassVar[TokenKind] = ...
    CloseBrace: ClassVar[TokenKind] = ...
    CloseBracket: ClassVar[TokenKind] = ...
    CloseParenthesis: ClassVar[TokenKind] = ...
    CmosKeyword: ClassVar[TokenKind] = ...
    Colon: ClassVar[TokenKind] = ...
    ColonEquals: ClassVar[TokenKind] = ...
    ColonSlash: ClassVar[TokenKind] = ...
    Comma: ClassVar[TokenKind] = ...
    ConfigKeyword: ClassVar[TokenKind] = ...
    ConstKeyword: ClassVar[TokenKind] = ...
    ConstraintKeyword: ClassVar[TokenKind] = ...
    ContextKeyword: ClassVar[TokenKind] = ...
    ContinueKeyword: ClassVar[TokenKind] = ...
    CoverGroupKeyword: ClassVar[TokenKind] = ...
    CoverKeyword: ClassVar[TokenKind] = ...
    CoverPointKeyword: ClassVar[TokenKind] = ...
    CrossKeyword: ClassVar[TokenKind] = ...
    DeassignKeyword: ClassVar[TokenKind] = ...
    DefParamKeyword: ClassVar[TokenKind] = ...
    DefaultKeyword: ClassVar[TokenKind] = ...
    DesignKeyword: ClassVar[TokenKind] = ...
    Directive: ClassVar[TokenKind] = ...
    DisableKeyword: ClassVar[TokenKind] = ...
    DistKeyword: ClassVar[TokenKind] = ...
    DoKeyword: ClassVar[TokenKind] = ...
    Dollar: ClassVar[TokenKind] = ...
    Dot: ClassVar[TokenKind] = ...
    DotStar: ClassVar[TokenKind] = ...
    DoubleAnd: ClassVar[TokenKind] = ...
    DoubleAt: ClassVar[TokenKind] = ...
    DoubleColon: ClassVar[TokenKind] = ...
    DoubleEquals: ClassVar[TokenKind] = ...
    DoubleEqualsQuestion: ClassVar[TokenKind] = ...
    DoubleHash: ClassVar[TokenKind] = ...
    DoubleMinus: ClassVar[TokenKind] = ...
    DoubleOr: ClassVar[TokenKind] = ...
    DoublePlus: ClassVar[TokenKind] = ...
    DoubleStar: ClassVar[TokenKind] = ...
    EdgeKeyword: ClassVar[TokenKind] = ...
    ElseKeyword: ClassVar[TokenKind] = ...
    EmptyMacroArgument: ClassVar[TokenKind] = ...
    EndCaseKeyword: ClassVar[TokenKind] = ...
    EndCheckerKeyword: ClassVar[TokenKind] = ...
    EndClassKeyword: ClassVar[TokenKind] = ...
    EndClockingKeyword: ClassVar[TokenKind] = ...
    EndConfigKeyword: ClassVar[TokenKind] = ...
    EndFunctionKeyword: ClassVar[TokenKind] = ...
    EndGenerateKeyword: ClassVar[TokenKind] = ...
    EndGroupKeyword: ClassVar[TokenKind] = ...
    EndInterfaceKeyword: ClassVar[TokenKind] = ...
    EndKeyword: ClassVar[TokenKind] = ...
    EndModuleKeyword: ClassVar[TokenKind] = ...
    EndOfFile: ClassVar[TokenKind] = ...
    EndPackageKeyword: ClassVar[TokenKind] = ...
    EndPrimitiveKeyword: ClassVar[TokenKind] = ...
    EndProgramKeyword: ClassVar[TokenKind] = ...
    EndPropertyKeyword: ClassVar[TokenKind] = ...
    EndSequenceKeyword: ClassVar[TokenKind] = ...
    EndSpecifyKeyword: ClassVar[TokenKind] = ...
    EndTableKeyword: ClassVar[TokenKind] = ...
    EndTaskKeyword: ClassVar[TokenKind] = ...
    EnumKeyword: ClassVar[TokenKind] = ...
    Equals: ClassVar[TokenKind] = ...
    EqualsArrow: ClassVar[TokenKind] = ...
    EventKeyword: ClassVar[TokenKind] = ...
    EventuallyKeyword: ClassVar[TokenKind] = ...
    Exclamation: ClassVar[TokenKind] = ...
    ExclamationDoubleEquals: ClassVar[TokenKind] = ...
    ExclamationEquals: ClassVar[TokenKind] = ...
    ExclamationEqualsQuestion: ClassVar[TokenKind] = ...
    ExpectKeyword: ClassVar[TokenKind] = ...
    ExportKeyword: ClassVar[TokenKind] = ...
    ExtendsKeyword: ClassVar[TokenKind] = ...
    ExternKeyword: ClassVar[TokenKind] = ...
    FinalKeyword: ClassVar[TokenKind] = ...
    FirstMatchKeyword: ClassVar[TokenKind] = ...
    ForKeyword: ClassVar[TokenKind] = ...
    ForceKeyword: ClassVar[TokenKind] = ...
    ForeachKeyword: ClassVar[TokenKind] = ...
    ForeverKeyword: ClassVar[TokenKind] = ...
    ForkJoinKeyword: ClassVar[TokenKind] = ...
    ForkKeyword: ClassVar[TokenKind] = ...
    FunctionKeyword: ClassVar[TokenKind] = ...
    GenVarKeyword: ClassVar[TokenKind] = ...
    GenerateKeyword: ClassVar[TokenKind] = ...
    GlobalKeyword: ClassVar[TokenKind] = ...
    GreaterThan: ClassVar[TokenKind] = ...
    GreaterThanEquals: ClassVar[TokenKind] = ...
    Hash: ClassVar[TokenKind] = ...
    HashEqualsHash: ClassVar[TokenKind] = ...
    HashMinusHash: ClassVar[TokenKind] = ...
    HighZ0Keyword: ClassVar[TokenKind] = ...
    HighZ1Keyword: ClassVar[TokenKind] = ...
    Identifier: ClassVar[TokenKind] = ...
    IfKeyword: ClassVar[TokenKind] = ...
    IfNoneKeyword: ClassVar[TokenKind] = ...
    IffKeyword: ClassVar[TokenKind] = ...
    IgnoreBinsKeyword: ClassVar[TokenKind] = ...
    IllegalBinsKeyword: ClassVar[TokenKind] = ...
    ImplementsKeyword: ClassVar[TokenKind] = ...
    ImpliesKeyword: ClassVar[TokenKind] = ...
    ImportKeyword: ClassVar[TokenKind] = ...
    InOutKeyword: ClassVar[TokenKind] = ...
    IncDirKeyword: ClassVar[TokenKind] = ...
    IncludeFileName: ClassVar[TokenKind] = ...
    IncludeKeyword: ClassVar[TokenKind] = ...
    InitialKeyword: ClassVar[TokenKind] = ...
    InputKeyword: ClassVar[TokenKind] = ...
    InsideKeyword: ClassVar[TokenKind] = ...
    InstanceKeyword: ClassVar[TokenKind] = ...
    IntKeyword: ClassVar[TokenKind] = ...
    IntegerBase: ClassVar[TokenKind] = ...
    IntegerKeyword: ClassVar[TokenKind] = ...
    IntegerLiteral: ClassVar[TokenKind] = ...
    InterconnectKeyword: ClassVar[TokenKind] = ...
    InterfaceKeyword: ClassVar[TokenKind] = ...
    IntersectKeyword: ClassVar[TokenKind] = ...
    JoinAnyKeyword: ClassVar[TokenKind] = ...
    JoinKeyword: ClassVar[TokenKind] = ...
    JoinNoneKeyword: ClassVar[TokenKind] = ...
    LargeKeyword: ClassVar[TokenKind] = ...
    LeftShift: ClassVar[TokenKind] = ...
    LeftShiftEqual: ClassVar[TokenKind] = ...
    LessThan: ClassVar[TokenKind] = ...
    LessThanEquals: ClassVar[TokenKind] = ...
    LessThanMinusArrow: ClassVar[TokenKind] = ...
    LetKeyword: ClassVar[TokenKind] = ...
    LibListKeyword: ClassVar[TokenKind] = ...
    LibraryKeyword: ClassVar[TokenKind] = ...
    LineContinuation: ClassVar[TokenKind] = ...
    LocalKeyword: ClassVar[TokenKind] = ...
    LocalParamKeyword: ClassVar[TokenKind] = ...
    LogicKeyword: ClassVar[TokenKind] = ...
    LongIntKeyword: ClassVar[TokenKind] = ...
    MacroEscapedQuote: ClassVar[TokenKind] = ...
    MacroPaste: ClassVar[TokenKind] = ...
    MacroQuote: ClassVar[TokenKind] = ...
    MacroUsage: ClassVar[TokenKind] = ...
    MacromoduleKeyword: ClassVar[TokenKind] = ...
    MatchesKeyword: ClassVar[TokenKind] = ...
    MediumKeyword: ClassVar[TokenKind] = ...
    Minus: ClassVar[TokenKind] = ...
    MinusArrow: ClassVar[TokenKind] = ...
    MinusColon: ClassVar[TokenKind] = ...
    MinusDoubleArrow: ClassVar[TokenKind] = ...
    MinusEqual: ClassVar[TokenKind] = ...
    ModPortKeyword: ClassVar[TokenKind] = ...
    ModuleKeyword: ClassVar[TokenKind] = ...
    NandKeyword: ClassVar[TokenKind] = ...
    NegEdgeKeyword: ClassVar[TokenKind] = ...
    NetTypeKeyword: ClassVar[TokenKind] = ...
    NewKeyword: ClassVar[TokenKind] = ...
    NextTimeKeyword: ClassVar[TokenKind] = ...
    NmosKeyword: ClassVar[TokenKind] = ...
    NoShowCancelledKeyword: ClassVar[TokenKind] = ...
    NorKeyword: ClassVar[TokenKind] = ...
    NotIf0Keyword: ClassVar[TokenKind] = ...
    NotIf1Keyword: ClassVar[TokenKind] = ...
    NotKeyword: ClassVar[TokenKind] = ...
    NullKeyword: ClassVar[TokenKind] = ...
    OneStep: ClassVar[TokenKind] = ...
    OpenBrace: ClassVar[TokenKind] = ...
    OpenBracket: ClassVar[TokenKind] = ...
    OpenParenthesis: ClassVar[TokenKind] = ...
    OpenParenthesisStar: ClassVar[TokenKind] = ...
    Or: ClassVar[TokenKind] = ...
    OrEqual: ClassVar[TokenKind] = ...
    OrEqualsArrow: ClassVar[TokenKind] = ...
    OrKeyword: ClassVar[TokenKind] = ...
    OrMinusArrow: ClassVar[TokenKind] = ...
    OutputKeyword: ClassVar[TokenKind] = ...
    PackageKeyword: ClassVar[TokenKind] = ...
    PackedKeyword: ClassVar[TokenKind] = ...
    ParameterKeyword: ClassVar[TokenKind] = ...
    Percent: ClassVar[TokenKind] = ...
    PercentEqual: ClassVar[TokenKind] = ...
    Placeholder: ClassVar[TokenKind] = ...
    Plus: ClassVar[TokenKind] = ...
    PlusColon: ClassVar[TokenKind] = ...
    PlusEqual: ClassVar[TokenKind] = ...
    PmosKeyword: ClassVar[TokenKind] = ...
    PosEdgeKeyword: ClassVar[TokenKind] = ...
    PrimitiveKeyword: ClassVar[TokenKind] = ...
    PriorityKeyword: ClassVar[TokenKind] = ...
    ProgramKeyword: ClassVar[TokenKind] = ...
    PropertyKeyword: ClassVar[TokenKind] = ...
    ProtectedKeyword: ClassVar[TokenKind] = ...
    Pull0Keyword: ClassVar[TokenKind] = ...
    Pull1Keyword: ClassVar[TokenKind] = ...
    PullDownKeyword: ClassVar[TokenKind] = ...
    PullUpKeyword: ClassVar[TokenKind] = ...
    PulseStyleOnDetectKeyword: ClassVar[TokenKind] = ...
    PulseStyleOnEventKeyword: ClassVar[TokenKind] = ...
    PureKeyword: ClassVar[TokenKind] = ...
    Question: ClassVar[TokenKind] = ...
    RandCKeyword: ClassVar[TokenKind] = ...
    RandCaseKeyword: ClassVar[TokenKind] = ...
    RandKeyword: ClassVar[TokenKind] = ...
    RandSequenceKeyword: ClassVar[TokenKind] = ...
    RcmosKeyword: ClassVar[TokenKind] = ...
    RealKeyword: ClassVar[TokenKind] = ...
    RealLiteral: ClassVar[TokenKind] = ...
    RealTimeKeyword: ClassVar[TokenKind] = ...
    RefKeyword: ClassVar[TokenKind] = ...
    RegKeyword: ClassVar[TokenKind] = ...
    RejectOnKeyword: ClassVar[TokenKind] = ...
    ReleaseKeyword: ClassVar[TokenKind] = ...
    RepeatKeyword: ClassVar[TokenKind] = ...
    RestrictKeyword: ClassVar[TokenKind] = ...
    ReturnKeyword: ClassVar[TokenKind] = ...
    RightShift: ClassVar[TokenKind] = ...
    RightShiftEqual: ClassVar[TokenKind] = ...
    RnmosKeyword: ClassVar[TokenKind] = ...
    RootSystemName: ClassVar[TokenKind] = ...
    RpmosKeyword: ClassVar[TokenKind] = ...
    RtranIf0Keyword: ClassVar[TokenKind] = ...
    RtranIf1Keyword: ClassVar[TokenKind] = ...
    RtranKeyword: ClassVar[TokenKind] = ...
    SAlwaysKeyword: ClassVar[TokenKind] = ...
    SEventuallyKeyword: ClassVar[TokenKind] = ...
    SNextTimeKeyword: ClassVar[TokenKind] = ...
    SUntilKeyword: ClassVar[TokenKind] = ...
    SUntilWithKeyword: ClassVar[TokenKind] = ...
    ScalaredKeyword: ClassVar[TokenKind] = ...
    Semicolon: ClassVar[TokenKind] = ...
    SequenceKeyword: ClassVar[TokenKind] = ...
    ShortIntKeyword: ClassVar[TokenKind] = ...
    ShortRealKeyword: ClassVar[TokenKind] = ...
    ShowCancelledKeyword: ClassVar[TokenKind] = ...
    SignedKeyword: ClassVar[TokenKind] = ...
    Slash: ClassVar[TokenKind] = ...
    SlashEqual: ClassVar[TokenKind] = ...
    SmallKeyword: ClassVar[TokenKind] = ...
    SoftKeyword: ClassVar[TokenKind] = ...
    SolveKeyword: ClassVar[TokenKind] = ...
    SpecParamKeyword: ClassVar[TokenKind] = ...
    SpecifyKeyword: ClassVar[TokenKind] = ...
    Star: ClassVar[TokenKind] = ...
    StarArrow: ClassVar[TokenKind] = ...
    StarCloseParenthesis: ClassVar[TokenKind] = ...
    StarEqual: ClassVar[TokenKind] = ...
    StaticKeyword: ClassVar[TokenKind] = ...
    StringKeyword: ClassVar[TokenKind] = ...
    StringLiteral: ClassVar[TokenKind] = ...
    Strong0Keyword: ClassVar[TokenKind] = ...
    Strong1Keyword: ClassVar[TokenKind] = ...
    StrongKeyword: ClassVar[TokenKind] = ...
    StructKeyword: ClassVar[TokenKind] = ...
    SuperKeyword: ClassVar[TokenKind] = ...
    Supply0Keyword: ClassVar[TokenKind] = ...
    Supply1Keyword: ClassVar[TokenKind] = ...
    SyncAcceptOnKeyword: ClassVar[TokenKind] = ...
    SyncRejectOnKeyword: ClassVar[TokenKind] = ...
    SystemIdentifier: ClassVar[TokenKind] = ...
    TableKeyword: ClassVar[TokenKind] = ...
    TaggedKeyword: ClassVar[TokenKind] = ...
    TaskKeyword: ClassVar[TokenKind] = ...
    ThisKeyword: ClassVar[TokenKind] = ...
    ThroughoutKeyword: ClassVar[TokenKind] = ...
    Tilde: ClassVar[TokenKind] = ...
    TildeAnd: ClassVar[TokenKind] = ...
    TildeOr: ClassVar[TokenKind] = ...
    TildeXor: ClassVar[TokenKind] = ...
    TimeKeyword: ClassVar[TokenKind] = ...
    TimeLiteral: ClassVar[TokenKind] = ...
    TimePrecisionKeyword: ClassVar[TokenKind] = ...
    TimeUnitKeyword: ClassVar[TokenKind] = ...
    TranIf0Keyword: ClassVar[TokenKind] = ...
    TranIf1Keyword: ClassVar[TokenKind] = ...
    TranKeyword: ClassVar[TokenKind] = ...
    Tri0Keyword: ClassVar[TokenKind] = ...
    Tri1Keyword: ClassVar[TokenKind] = ...
    TriAndKeyword: ClassVar[TokenKind] = ...
    TriKeyword: ClassVar[TokenKind] = ...
    TriOrKeyword: ClassVar[TokenKind] = ...
    TriRegKeyword: ClassVar[TokenKind] = ...
    TripleAnd: ClassVar[TokenKind] = ...
    TripleEquals: ClassVar[TokenKind] = ...
    TripleLeftShift: ClassVar[TokenKind] = ...
    TripleLeftShiftEqual: ClassVar[TokenKind] = ...
    TripleRightShift: ClassVar[TokenKind] = ...
    TripleRightShiftEqual: ClassVar[TokenKind] = ...
    TypeKeyword: ClassVar[TokenKind] = ...
    TypedefKeyword: ClassVar[TokenKind] = ...
    UWireKeyword: ClassVar[TokenKind] = ...
    UnbasedUnsizedLiteral: ClassVar[TokenKind] = ...
    UnionKeyword: ClassVar[TokenKind] = ...
    Unique0Keyword: ClassVar[TokenKind] = ...
    UniqueKeyword: ClassVar[TokenKind] = ...
    UnitSystemName: ClassVar[TokenKind] = ...
    Unknown: ClassVar[TokenKind] = ...
    UnsignedKeyword: ClassVar[TokenKind] = ...
    UntilKeyword: ClassVar[TokenKind] = ...
    UntilWithKeyword: ClassVar[TokenKind] = ...
    UntypedKeyword: ClassVar[TokenKind] = ...
    UseKeyword: ClassVar[TokenKind] = ...
    VarKeyword: ClassVar[TokenKind] = ...
    VectoredKeyword: ClassVar[TokenKind] = ...
    VirtualKeyword: ClassVar[TokenKind] = ...
    VoidKeyword: ClassVar[TokenKind] = ...
    WAndKeyword: ClassVar[TokenKind] = ...
    WOrKeyword: ClassVar[TokenKind] = ...
    WaitKeyword: ClassVar[TokenKind] = ...
    WaitOrderKeyword: ClassVar[TokenKind] = ...
    Weak0Keyword: ClassVar[TokenKind] = ...
    Weak1Keyword: ClassVar[TokenKind] = ...
    WeakKeyword: ClassVar[TokenKind] = ...
    WhileKeyword: ClassVar[TokenKind] = ...
    WildcardKeyword: ClassVar[TokenKind] = ...
    WireKeyword: ClassVar[TokenKind] = ...
    WithKeyword: ClassVar[TokenKind] = ...
    WithinKeyword: ClassVar[TokenKind] = ...
    XnorKeyword: ClassVar[TokenKind] = ...
    Xor: ClassVar[TokenKind] = ...
    XorEqual: ClassVar[TokenKind] = ...
    XorKeyword: ClassVar[TokenKind] = ...
    XorTilde: ClassVar[TokenKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TransListCoverageBinInitializerSyntax(CoverageBinInitializerSyntax):
    sets: Any
    def __init__(self, *args, **kwargs) -> None: ...

class TransRangeSyntax(SyntaxNode):
    items: Any
    repeat: TransRepeatRangeSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class TransRepeatRangeSyntax(SyntaxNode):
    closeBracket: Token
    openBracket: Token
    selector: SelectorSyntax
    specifier: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TransSetSyntax(SyntaxNode):
    closeParen: Token
    openParen: Token
    ranges: Any
    def __init__(self, *args, **kwargs) -> None: ...

class TransparentMemberSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def wrapped(self) -> Symbol: ...

class Trivia:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: TriviaKind, arg1: str) -> None: ...
    def getExplicitLocation(self) -> Optional[SourceLocation]: ...
    def getRawText(self) -> str: ...
    def getSkippedTokens(self, *args, **kwargs) -> Any: ...
    def syntax(self, *args, **kwargs) -> Any: ...
    @property
    def kind(self) -> TriviaKind: ...

class TriviaKind:
    __members__: ClassVar[dict] = ...  # read-only
    BlockComment: ClassVar[TriviaKind] = ...
    Directive: ClassVar[TriviaKind] = ...
    DisabledText: ClassVar[TriviaKind] = ...
    EndOfLine: ClassVar[TriviaKind] = ...
    LineComment: ClassVar[TriviaKind] = ...
    SkippedSyntax: ClassVar[TriviaKind] = ...
    SkippedTokens: ClassVar[TriviaKind] = ...
    Unknown: ClassVar[TriviaKind] = ...
    Whitespace: ClassVar[TriviaKind] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Type(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    def coerceValue(self, arg0: ConstantValue) -> ConstantValue: ...
    def getCommonBase(self, *args, **kwargs) -> Any: ...
    def implements(self, arg0: Type) -> bool: ...
    def isAssignmentCompatible(self, arg0: Type) -> bool: ...
    def isBitstreamCastable(self, arg0: Type) -> bool: ...
    def isCastCompatible(self, arg0: Type) -> bool: ...
    def isDerivedFrom(self, arg0: Type) -> bool: ...
    def isEquivalent(self, arg0: Type) -> bool: ...
    def isMatching(self, arg0: Type) -> bool: ...
    def isValidForRand(self, arg0: RandMode) -> bool: ...
    @property
    def arrayElementType(self) -> Type: ...
    @property
    def associativeIndexType(self) -> Type: ...
    @property
    def bitWidth(self) -> int: ...
    @property
    def bitstreamWidth(self) -> int: ...
    @property
    def canBeStringLike(self) -> bool: ...
    @property
    def canonicalType(self) -> Type: ...
    @property
    def defaultValue(self) -> ConstantValue: ...
    @property
    def fixedRange(self) -> ConstantRange: ...
    @property
    def hasFixedRange(self) -> bool: ...
    @property
    def integralFlags(self) -> IntegralFlags: ...
    @property
    def isAggregate(self) -> bool: ...
    @property
    def isAlias(self) -> bool: ...
    @property
    def isArray(self) -> bool: ...
    @property
    def isAssociativeArray(self) -> bool: ...
    @property
    def isBitstreamType(self) -> bool: ...
    @property
    def isBooleanConvertible(self) -> bool: ...
    @property
    def isByteArray(self) -> bool: ...
    @property
    def isCHandle(self) -> bool: ...
    @property
    def isClass(self) -> bool: ...
    @property
    def isCovergroup(self) -> bool: ...
    @property
    def isDynamicallySizedArray(self) -> bool: ...
    @property
    def isEnum(self) -> bool: ...
    @property
    def isError(self) -> bool: ...
    @property
    def isEvent(self) -> bool: ...
    @property
    def isFixedSize(self) -> bool: ...
    @property
    def isFloating(self) -> bool: ...
    @property
    def isFourState(self) -> bool: ...
    @property
    def isIntegral(self) -> bool: ...
    @property
    def isIterable(self) -> bool: ...
    @property
    def isNull(self) -> bool: ...
    @property
    def isNumeric(self) -> bool: ...
    @property
    def isPackedArray(self) -> bool: ...
    @property
    def isPackedUnion(self) -> bool: ...
    @property
    def isPredefinedInteger(self) -> bool: ...
    @property
    def isPropertyType(self) -> bool: ...
    @property
    def isQueue(self) -> bool: ...
    @property
    def isScalar(self) -> bool: ...
    @property
    def isSequenceType(self) -> bool: ...
    @property
    def isSigned(self) -> bool: ...
    @property
    def isSimpleBitVector(self) -> bool: ...
    @property
    def isSimpleType(self) -> bool: ...
    @property
    def isSingular(self) -> bool: ...
    @property
    def isString(self) -> bool: ...
    @property
    def isStruct(self) -> bool: ...
    @property
    def isTaggedUnion(self) -> bool: ...
    @property
    def isTypeRefType(self) -> bool: ...
    @property
    def isUnbounded(self) -> bool: ...
    @property
    def isUnpackedArray(self) -> bool: ...
    @property
    def isUnpackedStruct(self) -> bool: ...
    @property
    def isUnpackedUnion(self) -> bool: ...
    @property
    def isUntypedType(self) -> bool: ...
    @property
    def isValidForDPIArg(self) -> bool: ...
    @property
    def isValidForDPIReturn(self) -> bool: ...
    @property
    def isValidForSequence(self) -> bool: ...
    @property
    def isVirtualInterface(self) -> bool: ...
    @property
    def isVoid(self) -> bool: ...

class TypeAliasType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def firstForwardDecl(self) -> ForwardingTypedefSymbol: ...
    @property
    def targetType(self) -> DeclaredType: ...
    @property
    def visibility(self) -> Visibility: ...

class TypeAssignmentSyntax(SyntaxNode):
    assignment: EqualsTypeClauseSyntax
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TypeParameterDeclarationSyntax(ParameterDeclarationBaseSyntax):
    declarators: Any
    typeKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TypeParameterSymbol(Symbol, ParameterSymbolBase):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def targetType(self) -> Any: ...
    @property
    def typeAlias(self) -> Any: ...

class TypePrinter:
    options: TypePrintingOptions
    def __init__(self) -> None: ...
    def append(self, arg0: Type) -> None: ...
    def clear(self) -> None: ...
    def toString(self) -> str: ...

class TypePrintingOptions:
    class AnonymousTypeStyle:
        __members__: ClassVar[dict] = ...  # read-only
        FriendlyName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
        SystemName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    FriendlyName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
    SystemName: ClassVar[TypePrintingOptions.AnonymousTypeStyle] = ...
    addSingleQuotes: bool
    anonymousTypeStyle: Any
    elideScopeNames: bool
    printAKA: bool
    def __init__(self, *args, **kwargs) -> None: ...

class TypeRefType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class TypeReferenceExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def targetType(self) -> Any: ...

class TypeReferenceSyntax(DataTypeSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    typeKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class TypedefDeclarationSyntax(MemberSyntax):
    dimensions: Any
    name: Token
    semi: Token
    type: DataTypeSyntax
    typedefKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpBodySyntax(SyntaxNode):
    endtable: Token
    entries: Any
    initialStmt: UdpInitialStmtSyntax
    portDecls: Any
    table: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpDeclarationSyntax(MemberSyntax):
    body: UdpBodySyntax
    endBlockName: NamedBlockClauseSyntax
    endprimitive: Token
    name: Token
    portList: UdpPortListSyntax
    primitive: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpEdgeIndicatorSyntax(SyntaxNode):
    closeParen: Token
    first: Token
    openParen: Token
    second: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpEntrySyntax(SyntaxNode):
    colon1: Token
    colon2: Token
    current: Token
    edgeIndicator: UdpEdgeIndicatorSyntax
    next: Token
    postInputs: Any
    preInputs: Any
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpInitialStmtSyntax(SyntaxNode):
    equals: Token
    initial: Token
    name: Token
    semi: Token
    value: ExpressionSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class UdpInputPortDeclSyntax(UdpPortDeclSyntax):
    keyword: Token
    names: Any
    def __init__(self, *args, **kwargs) -> None: ...

class UdpOutputPortDeclSyntax(UdpPortDeclSyntax):
    initializer: EqualsValueClauseSyntax
    keyword: Token
    name: Token
    reg: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UdpPortDeclSyntax(SyntaxNode):
    attributes: Any
    def __init__(self, *args, **kwargs) -> None: ...

class UdpPortListSyntax(SyntaxNode):
    def __init__(self, *args, **kwargs) -> None: ...

class UnaryAssertionExpr(AssertionExpr):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> AssertionExpr: ...
    @property
    def op(self) -> UnaryAssertionOperator: ...
    @property
    def range(self) -> Optional[SequenceRange]: ...

class UnaryAssertionOperator:
    __members__: ClassVar[dict] = ...  # read-only
    Always: ClassVar[UnaryAssertionOperator] = ...
    Eventually: ClassVar[UnaryAssertionOperator] = ...
    NextTime: ClassVar[UnaryAssertionOperator] = ...
    Not: ClassVar[UnaryAssertionOperator] = ...
    SAlways: ClassVar[UnaryAssertionOperator] = ...
    SEventually: ClassVar[UnaryAssertionOperator] = ...
    SNextTime: ClassVar[UnaryAssertionOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnaryBinsSelectExpr(BinsSelectExpr):
    class Op:
        __members__: ClassVar[dict] = ...  # read-only
        Negation: ClassVar[UnaryBinsSelectExpr.Op] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    Negation: ClassVar[UnaryBinsSelectExpr.Op] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def expr(self) -> BinsSelectExpr: ...
    @property
    def op(self) -> Any: ...

class UnaryBinsSelectExprSyntax(BinsSelectExpressionSyntax):
    expr: BinsSelectConditionExprSyntax
    op: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnaryExpression(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def op(self) -> UnaryOperator: ...
    @property
    def operand(self) -> Expression: ...

class UnaryOperator:
    __members__: ClassVar[dict] = ...  # read-only
    BitwiseAnd: ClassVar[UnaryOperator] = ...
    BitwiseNand: ClassVar[UnaryOperator] = ...
    BitwiseNor: ClassVar[UnaryOperator] = ...
    BitwiseNot: ClassVar[UnaryOperator] = ...
    BitwiseOr: ClassVar[UnaryOperator] = ...
    BitwiseXnor: ClassVar[UnaryOperator] = ...
    BitwiseXor: ClassVar[UnaryOperator] = ...
    LogicalNot: ClassVar[UnaryOperator] = ...
    Minus: ClassVar[UnaryOperator] = ...
    Plus: ClassVar[UnaryOperator] = ...
    Postdecrement: ClassVar[UnaryOperator] = ...
    Postincrement: ClassVar[UnaryOperator] = ...
    Predecrement: ClassVar[UnaryOperator] = ...
    Preincrement: ClassVar[UnaryOperator] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnaryPropertyExprSyntax(PropertyExprSyntax):
    expr: PropertyExprSyntax
    op: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnarySelectPropertyExprSyntax(PropertyExprSyntax):
    closeBracket: Token
    expr: PropertyExprSyntax
    op: Token
    openBracket: Token
    selector: SelectorSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class UnbasedUnsizedIntegerLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def literalValue(self) -> Any: ...
    @property
    def value(self) -> Any: ...

class Unbounded:
    def __init__(self) -> None: ...

class UnboundedLiteral(Expression):
    def __init__(self, *args, **kwargs) -> None: ...

class UnboundedType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class UnconditionalBranchDirectiveSyntax(DirectiveSyntax):
    disabledTokens: Any
    def __init__(self, *args, **kwargs) -> None: ...

class UnconnectedDrive:
    __members__: ClassVar[dict] = ...  # read-only
    None: ClassVar[UnconnectedDrive] = ...
    Pull0: ClassVar[UnconnectedDrive] = ...
    Pull1: ClassVar[UnconnectedDrive] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class UnconnectedDriveDirectiveSyntax(DirectiveSyntax):
    strength: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UndefDirectiveSyntax(DirectiveSyntax):
    name: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UniquenessConstraint(Constraint):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def items(self) -> span[Expression]: ...

class UniquenessConstraintSyntax(ConstraintItemSyntax):
    ranges: OpenRangeListSyntax
    semi: Token
    unique: Token
    def __init__(self, *args, **kwargs) -> None: ...

class UnknownModuleSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isChecker(self) -> bool: ...
    @property
    def moduleName(self) -> str: ...
    @property
    def paramExpressions(self) -> span[Expression]: ...
    @property
    def portConnections(self) -> span[AssertionExpr]: ...
    @property
    def portNames(self) -> span[str]: ...

class UnpackedStructType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def systemId(self) -> int: ...

class UnpackedUnionType(Type, Scope):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isTagged(self) -> bool: ...
    @property
    def systemId(self) -> int: ...

class UntypedType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class UserDefinedNetDeclarationSyntax(MemberSyntax):
    declarators: Any
    delay: TimingControlSyntax
    netType: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class ValueExpressionBase(Expression):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self) -> Any: ...

class ValueSymbol(Symbol):
    class Driver:
        def __init__(self, *args, **kwargs) -> None: ...
        def overlaps(self, arg0: ValueSymbol.Driver) -> bool: ...
        @property
        def containingSymbol(self) -> Symbol: ...
        @property
        def hasError(self) -> bool: ...
        @property
        def hasOriginalRange(self) -> bool: ...
        @property
        def isClockVar(self) -> bool: ...
        @property
        def isInInitialBlock(self) -> bool: ...
        @property
        def isInSingleDriverProcedure(self) -> bool: ...
        @property
        def isInSubroutine(self) -> bool: ...
        @property
        def isInputPort(self) -> bool: ...
        @property
        def isLocalVarFormalArg(self) -> bool: ...
        @property
        def isUnidirectionalPort(self) -> bool: ...
        @property
        def kind(self) -> DriverKind: ...
        @property
        def nextDriver(self) -> ValueSymbol.Driver: ...
        @property
        def numPrefixEntries(self) -> int: ...
        @property
        def originalRange(self) -> SourceRange: ...
        @property
        def prefix(self) -> span[ConstantRange]: ...
        @property
        def sourceRange(self) -> SourceRange: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def firstDriver(self) -> Any: ...
    @property
    def initializer(self) -> Expression: ...
    @property
    def type(self) -> Any: ...

class VariableDeclStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def symbol(self) -> Any: ...

class VariableDimensionSyntax(SyntaxNode):
    closeBracket: Token
    openBracket: Token
    specifier: DimensionSpecifierSyntax
    def __init__(self, *args, **kwargs) -> None: ...

class VariableFlags:
    __members__: ClassVar[dict] = ...  # read-only
    CompilerGenerated: ClassVar[VariableFlags] = ...
    Const: ClassVar[VariableFlags] = ...
    CoverageSampleFormal: ClassVar[VariableFlags] = ...
    ImmutableCoverageOption: ClassVar[VariableFlags] = ...
    None: ClassVar[VariableFlags] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VariableLifetime:
    __members__: ClassVar[dict] = ...  # read-only
    Automatic: ClassVar[VariableLifetime] = ...
    Static: ClassVar[VariableLifetime] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VariablePattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def variable(self) -> Any: ...

class VariablePatternSyntax(PatternSyntax):
    dot: Token
    variableName: Token
    def __init__(self, *args, **kwargs) -> None: ...

class VariablePortHeaderSyntax(PortHeaderSyntax):
    constKeyword: Token
    dataType: DataTypeSyntax
    direction: Token
    varKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class VariableSymbol(ValueSymbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def flags(self) -> VariableFlags: ...
    @property
    def lifetime(self) -> VariableLifetime: ...

class VersionInfo:
    def __init__(self, *args, **kwargs) -> None: ...
    def getHash(self, *args, **kwargs) -> Any: ...
    def getMajor(self, *args, **kwargs) -> Any: ...
    def getMinor(self, *args, **kwargs) -> Any: ...
    def getPatch(self, *args, **kwargs) -> Any: ...

class VirtualInterfaceType(Type):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def iface(self) -> InstanceSymbol: ...
    @property
    def modport(self) -> ModportSymbol: ...

class VirtualInterfaceTypeSyntax(DataTypeSyntax):
    interfaceKeyword: Token
    modport: DotMemberClauseSyntax
    name: Token
    parameters: ParameterValueAssignmentSyntax
    virtualKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class Visibility:
    __members__: ClassVar[dict] = ...  # read-only
    Local: ClassVar[Visibility] = ...
    Protected: ClassVar[Visibility] = ...
    Public: ClassVar[Visibility] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VoidCastedCallStatementSyntax(StatementSyntax):
    apostrophe: Token
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    semi: Token
    voidKeyword: Token
    def __init__(self, *args, **kwargs) -> None: ...

class VoidType(Type):
    def __init__(self, *args, **kwargs) -> None: ...

class WaitForkStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...

class WaitForkStatementSyntax(StatementSyntax):
    fork: Token
    semi: Token
    wait: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WaitOrderStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def events(self) -> span[Expression]: ...
    @property
    def ifFalse(self) -> Statement: ...
    @property
    def ifTrue(self) -> Statement: ...

class WaitOrderStatementSyntax(StatementSyntax):
    action: ActionBlockSyntax
    closeParen: Token
    names: Any
    openParen: Token
    wait_order: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WaitStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def cond(self) -> Expression: ...
    @property
    def stmt(self) -> Statement: ...

class WaitStatementSyntax(StatementSyntax):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    statement: StatementSyntax
    wait: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WhileLoopStatement(Statement):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def body(self) -> Statement: ...
    @property
    def cond(self) -> Expression: ...

class WildcardDimensionSpecifierSyntax(DimensionSpecifierSyntax):
    star: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardImportSymbol(Symbol):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def isFromExport(self) -> bool: ...
    @property
    def package(self) -> PackageSymbol: ...
    @property
    def packageName(self) -> str: ...

class WildcardPattern(Pattern):
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardPatternSyntax(PatternSyntax):
    dotStar: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardPortConnectionSyntax(PortConnectionSyntax):
    dotStar: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardPortListSyntax(PortListSyntax):
    closeParen: Token
    dotStar: Token
    openParen: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WildcardUdpPortListSyntax(UdpPortListSyntax):
    closeParen: Token
    dotStar: Token
    openParen: Token
    semi: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WithClauseSyntax(SyntaxNode):
    closeParen: Token
    expr: ExpressionSyntax
    openParen: Token
    with: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WithFunctionClauseSyntax(SyntaxNode):
    name: NameSyntax
    with: Token
    def __init__(self, *args, **kwargs) -> None: ...

class WithFunctionSampleSyntax(SyntaxNode):
    function: Token
    portList: FunctionPortListSyntax
    sample: Token
    with: Token
    def __init__(self, *args, **kwargs) -> None: ...

class logic_t:
    x: ClassVar[logic_t] = ...  # read-only
    z: ClassVar[logic_t] = ...  # read-only
    __hash__: ClassVar[None] = ...
    value: int
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: int) -> None: ...
    def __and__(self, arg0: logic_t) -> logic_t: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, arg0: logic_t) -> logic_t: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> logic_t: ...
    def __ne__(self, arg0: logic_t) -> logic_t: ...
    def __or__(self, arg0: logic_t) -> logic_t: ...
    def __xor__(self, arg0: logic_t) -> logic_t: ...
    @property
    def isUnknown(self) -> bool: ...

def clog2(arg0) -> int: ...
def literalBaseFromChar(arg0: str, arg1: LiteralBase) -> bool: ...
def suffixToTimeUnit(arg0: str, arg1: TimeUnit) -> bool: ...
def timeUnitToSuffix(arg0: TimeUnit) -> str: ...
